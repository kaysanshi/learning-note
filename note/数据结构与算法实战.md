## 数据结构与算法实战

### 程序的本质

程序是有一系列的机器指令构成。

程序=数据结构+算法

数据结构与算法是相辅相成的。

#### **数据结构：**

数据结构是计算机存储，组织数据的方式。**数据结构是指的相互之间存在一种或多种特定关系的数据元素的集合**。通常情况下精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。

对**处理的问题如何表示**，即问题的**数学模型**是什么

简言之：是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。

<font color="red">“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。</font>

##### 基本术语：

###### 数据(Data)：

​     **在计算机科学中，是指所有**能输入到计算机中并被计算机程序处理的符号的总称（**集合**）  它是对客观事物的符号表示（描述），是计算机处理的信息的特定的符号表示形式（信息的载体）。

​     **数据结构中所讨论数据的范畴很广泛，如：字符、声音、图形、图像等多媒体信息。随着计算机的发展，数据的范畴不断扩大**

比如：

```
struct student{
	long num;
	char name[20];
	char sex;
	char addr[30];
}
struct student s1,s2[6];
```

###### 数据元素(Data Element)

**是数据 ( 集合 ) 中的一个 “ 个体 ” ，在计算机中通常作为一个整体进行考虑和处理。 是数据结构中讨论的 “ 基本单位 ” ， 但不是 最小 单位，它常常有若干 数据项 （ 是对数据元素 不同 属性 的描述 ， 具有 独立的意义 ） 组成 。**

比如：**在学生信息管理系统中， 一条学生纪录 就是 一个数据元素 （学号、姓名、性别等数据项组成）**

| 学号  | 姓名 | 班级    | 地址 |
| ----- | ---- | ------- | ---- |
| s0001 | scd  | class01 | addr |

**数据元素有两类。**

- 一类是不可分割的具有 “原子”型数据元素。如：整数 字符。
- 另一类：由多个款项构成的数据元素（结构型） 其中每个款项被称为一个 “数据项” 是对数据元素某种属性的描述具有独立意义。



###### 关键字

**指能识别一个或多个数据元素的数据项。若能起 唯一 识别作用，则称之为**
**“ 主 ”** **关键字 ，否则称之为“ 次 ”关键字** 比如学号为主关键字。其余为次关键字。

###### 数据对象(Data Object):

是性质相同的数据元素的集合，是数据的一个子集。比如 整数，实数，都是数据的一个子集



[![DiyNp4.png](https://s3.ax1x.com/2020/11/15/DiyNp4.png)](https://imgchr.com/i/DiyNp4)

##### **数据的逻辑结构：**

<font color="red">数据的逻辑结构反应的是数据元素之间的逻辑关系，是指数据元素之间的前后间的关系，而与元素所存储的位置无关</font>。逻辑结构包含：

- 集合：数据结构中的元素之间除了“同一集合”的相互关系外，别无其他关系。
- 线性结构：数据结构中的元素存在一对一的相互关系。
- 树形结构：数据结构中的元素存在一对多党的相互关系。
- 图形结构：数据结构中的元素存在多对多的相互关系。

一般按照逻辑结构分类数据结构可分为：

线性结构：线性结构就是表中各个结点具有线性关系。如果从数据结构的语言来描述，线性结构应该包括如下几点：

- 线性结构是非空集合

- 线性结构有且仅有一个开始结点和一个终端结点。

- 线性结构所有的结点都最多有一个直接前趋结点和一个后继结点。

  包含：线性表，栈，队列，串

非线性结构：线性结构就是表中各个结点具有线性关系。如果从数据结构的语言来描述，线性结构应该包括如下几点：

- 非线性结构是非空集。

- 非线性结构的一个结点可能有多个直接结点和多个后继结点。

  包含：数组，广义表，树结构和图结构

###### 逻辑结构的表示

**数据结构的形式定义为一个二元组：**

​            **Data-Structure=(  D  ，  S)**

**其中：  D  是数据元素的  有限  集，**

​      **S  是  D  上  关系的有限  集。**

> **例  复数的数据结构定义如下  :** **(  复数  x=C1 + C2** **i** **)**
>
> ​           **Complex=(  C  ，  R  )**
>
> **其中：**
>
>   **C  是含两个实数的集合  ﹛  C1  ，  C2  ﹜  ，分别表示复数的  实部  和  虚部  。**
>
>   **R  ={P}  ，  P  是定义在集合上的一种序偶关系：**
>
> ​         **{<C1  ，  C2>}  。  有序对  <>  ,  区别  （）**
>
> **有序对  <  x,y  >  －  y  是  x  的后继，**
> **x  是  y  的前驱：“  相邻  ”**
>
> **一个  <  x,y  >  的  有序对  是构成关系的  基本单位**





##### **数据的物理结构：**

指数据的[逻辑结构]在计算机存储空间的存放形式。

数据的物理结构是数据结构在计算机中的表示（又称映像），它包括数据元素的机内表示和关系的机内表示。由于具体实现的方法有顺序、链接、索引、散列等多种，所以，一种数据结构可表示成一种或多种存储结构。

数据元素的机内表示（映像方法）： 用二进制位（bit）的位串表示数据元素。通常称这种位串为节点（node）。当数据元素有若干个数据项组成时，位串中与各个数据项对应的子位串称为数据域（data field）。因此，节点是数据元素的机内表示（或机内映像）。

关系的机内表示（映像方法）：数据元素之间的关系的机内表示可以分为顺序映像和非顺序映像，常用两种存储结构：顺序存储结构和链式存储结构。顺序映像借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。非顺序映像借助指示元素存储位置的指针（pointer）来表示数据元素之间的逻辑关系。

##### **数据的存储结构：**

数据的逻辑结构在计算机存储空间中的存放形式称为数据的物理结构(也称为存储结构)。一般来说，一种数据结构的逻辑结构根据需要可以表示成多种存储结构，常用的存储结构有顺序存储、链式存储、索引存储和哈希存储等

- **顺序存储结构的特点是：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系；**
- **非顺序存储的特点是：借助指示元素存储地址的指针表示数据元素之间的逻辑关系**

[![DixLu9.png](https://s3.ax1x.com/2020/11/15/DixLu9.png)](https://imgchr.com/i/DixLu9)
[![DixbjJ.png](https://s3.ax1x.com/2020/11/15/DixbjJ.png)](https://imgchr.com/i/DixbjJ)

#### 算法：

算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰[指令]，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的[输入]，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用[空间复杂度]与[时间复杂度]来衡量。

算法中的指令描述的是一个[计算]，当其[运行]时能从一个初始状态和（可能为空的）初始输入开始，经过一系列**有限**而清晰定义的状态，最终产生**输出**并**停止**于一个终态。一个状态到另一个状态的转移不一定是确定的。随机化算法在内的一些算法，包含了一些随机输入。

**特征：**

- 有穷性（Finiteness：算法的有穷性是指算法必须能在执行有限个步骤之后终止；
- 确切性(Definiteness)：算法的每一步骤必须有确切的定义；
- 输入项(Input)：一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；
- 输出项(Output)：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；
- 可行性(Effectiveness)：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算[步骤](https://baike.baidu.com/item/步骤/7066340)都可以在有限时间内完成（也称之为有效性）

**算法的评定：**

- 时间复杂度：算法的时间复杂度是指执行算法所需要的计算工作量。一般来说，计算机算法是问题规模n 的函数f(n)，算法的时间复杂度也因此记做。T(n)=Ο(f(n))
- 因此，问题的规模n 越大，算法执行的时间的增长率与f(n) 的增长率正相关，称作[渐进时间复杂度](https://baike.baidu.com/item/渐进时间复杂度)（Asymptotic Time Complexity）。
- 空间复杂度：算法的[空间复杂度](https://baike.baidu.com/item/空间复杂度/9664257)是指算法需要消耗的内存空间。其计算和表示方法与时间[复杂度](https://baike.baidu.com/item/复杂度)类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。
- 正确性：算法的正确性是评价一个算法优劣的最重要的标准。
- 可读性：算法的可读性是指一个算法可供人们阅读的容易程度。 [1] 
- 健壮性：健壮性是指一个算法对不合理数据输入的反应能力和处理能力，也称为**容错性**

### 函数与递归

为何自己写不出递归呢？

需要 需要确定信念。确定递归的结束条件和递归条件

```java
 /**
     * 递归函数求阶乘
     *
     * @param n
     * @return
     */
    private static int fact(int n) {
        // 递归必须确定结束条件
        if (n < 2) {
            return 1;
        }
        return n * fact(n - 1);
    }

    /**
     * 汉诺塔
     *
     * @param n   盘子数
     * @param src 元盘子
     * @param mid 中间盘子
     * @param tar 目标盘子
     */
    private static void hanoi(int n, int src, int mid, int tar) {
        // 确定结束条件
        if (n == 1) {
            System.out.println(src + "-->" + tar);
        } else {
            hanoi(n - 1, src, tar, mid); // 把n-1个盘子从元盘子借助目标柱子放到中间柱子
            hanoi(1, src, mid, tar); // 把一个盘子从原主借助中间住放到目标住
            hanoi(n - 1, mid, src, tar); // 把n-1个盘子从中间住借助源住放到目标住
        }

    }
```

### 数组与字符串

#### 数组：

##### 数组的定义：

就是线性表的实现。

**c语言**

定义： `int array[N] 或者 int *array = malloc();`

数组的名不是指针。

```c
#include <stdio.h>
#include <stdio.h>
// 这个地方其实是传入的数组的地址 *array，和大小
int func(int *array,int size){
    // array[0] 其实就是指针 array求值得出首地址
	return array[0]; // 等价于 *(array+0);
}
int main(int argc,const char * argv[]){
    // array是一个数组
	int array[100] = {11,22,33,44};
    // 指针的形式
	int *p = malloc(100 * sizeof(int));
    // 在这里是获取到了数组的指针
    printf("%d\n",*(array+1));
    
    // 传入的其实是数组首地址的指针
	printf("%d\n",func(array,100));
	return 0;
}
```

**c++:**

数组定义：`int array[N] 或 int * array = new int[N];`

**java**

数组定义：`int array[] = new int[N];`

```java
public class main{
	public static void main(String[] args){
		int [] array = new int[10];
		array[1]=222;
		array[2]=333;
		System.out.println(array.length);
        ArrayList<Integer> list = new ArrayList<>();
        list.add(123);
        list.add(22);
        System.out.println(list);
	}
}
```

**python**

数组定义： `array = [];`

##### 数组元素的查找：

###### c语言实现：

```c
#include <stdio.h>

/**
** 根据值找到下标
*/
int findX(int * array,int size,int x){
	int flag=0;
	int index=-1;
	for(int i=0;i<size;i++){
		if(array[i]==x){
			flag =1;
			index = i;
		}
	}
	return index;
}
/**
** 根据下标找到值,并把原来的地址给返回过来，并返回状态。
*/
int findElement(int * array,int size, int k, int *px){
    if(k>=size || k<0) return 0;
    else{
        *px=array[k];
        return 1;
    }
}
/**
* 查找最大的。
*/
int findMax(int * array, int size){
    // 是将数组中的一个元素初始为max;
    int max =array[0];
    for(int i=1;i<size;i++){
        if(max<array[i]) max = array[i];
    }
    return max;
}
int main(int argc,const char * argv[]){
	int array[10] = {111,112,33,44,55};
	int x;
	x=12;
	int k;
	k= findX(array,10,x);
	printf("%d\n",k);
    int m,flag;
    // 传入的是数组引用，长度，和下标，和地址
    flag= findElement(array,10,3,&m);
    printf("%d,%d\n",flag,m);
	// 查找最大值
    int max ;
    max = findMax(array,10);
    printf("%d\n",max);
	return 0;
}
```

##### **求两个100位的十进制的和。**

###### C语言实现

```c
int main(int argc, const char * argv[]){
    // 
    // 思路 用数组 ，数组的底位存0号元素(如果0号元素存在高位，则是不可以进位的)
    int a[11] = {0,9,8,7,6,5,4,3,2,1};
    int b[11] = {1,2,3,4,5,6,7,8,9,9};
    int sum[11] = {0};
    int carry=0;//进位操作
    // i< 11是为了计算最后一个
    for(int i=0;i<11;i++){
        int s;
        s=a[i]+b[i]+carry;
        carry = s/10;
        sum[i] = s%10;
    }
    for(int i=10;i>=0;i--){
        printf("%d",sum[i]);
    }
    putchar('\n');
	return 0;
}
```

###### java 实现：

```java
public static void main(String[] args){
	BigInteger a= new BigInteger("12345678");
	BigInteger b= new BigInteger("12345678");
	BigInteger c= a.add(b);
	System.out.println(c);
}
```

#### 二维数组

二维数组的实质：数组的数组。数组中的每一个元素仍然是个数组。

逻辑上可看做二维，其实并不是二维的

**c语言**

`int array [][]  与 int **array`

`int array[3][4];和int **pa 的中的array和pa类型是相同的，但是 pa== array的写法是错误的`

`int array [ ][ ]` 与`int * *`

array是数组的数组。

int *p ===> 是p 指向一个整形变量。

p[2] <==> *(p+2)  就是 p指向的整形变量再+2的位置就是 p[2]

int * * p  因为*靠p元素最近，所以p是一个指针。所以 * * p是指的是指针的指针。`p[1][1]`与 `p[0][1]`的位置截然不同，并不是相差一个 

`int * *p= array是错误的`

```c
#include <stdio.h>

int main(void) { 
	printf("test");
	int array[3][5]; // 是由int[5]
	
	//int *p[5];
	//p =array; // 这样是错误的。
	
	
	int (*p)[5];
	p = array; // 数组名赋值与指针。 那也就是 array是 一个指针。
	
	int a[10];
	int *pa =a // s数组的名求值可获取数组元素的受地址。所以 *pa就是一个指针。
	
	return 0;
}
```

**数组传参：**

```c
#include <stdio.h>
vaid func(int (*)[5] , int ){
    // int (*)[5] 就是一个指向[5]的指针
}
void func(int array[][5] ,int k){
    // int array[][5]==>int (*p) [5];
    
}

int main(void) { 
	printf("test");
	int array[3][5]; // 是由int[5]
	
	//int *p[5];
	//p =array; // 这样是错误的。
	
	
	int (*p)[5];
	p = array; // 数组名赋值与指针。 那也就是 array是 一个指针。
	
	// 这传递的是指针
	func(array, 3);
	
	int a[10];
	int *pa =a // s数组的名求值可获取数组元素的受地址。所以 *pa就是一个指针。
	
	return 0;
}
```

**`java`**

```java
public void test(){
    // 这是个3行的但是列未定义。
	int[][] array= new int[3][];
	array[0] = new int[5]; // 第0行有5列 ，创建有5个整形变量的数组
	arry[1] = new int[4];
	array[2]= new int[3];
}
```



##### 大炮打蚊子案例：

```c
/**
 * 蚊子分布在一个M×N格的二维平面上，每只蚊子占据一格。向该平面的任意位置发射炮弹，炮弹的杀伤范围如下示意：

 O
OXO
 O
其中，X为炮弹落点中心，O为紧靠中心的四个有杀伤力的格子范围。若蚊子被炮弹命中（位于X格），一击毙命，若仅被杀伤（位于O格），则损失一半的生命力。也就是说，一次命中或者两次杀伤均可消灭蚊子。现在给出蚊子的分布情况以及连续k发炮弹的落点，给出每炮消灭的蚊子数。

输入格式:
第一行为两个不超过20的正整数M和N，中间空一格，表示二维平面有M行、N列。

接下来M行，每行有N个0或者#字符，其中#表示所在格子有蚊子。

接下来一行，包含一个不超过400的正整数k，表示发射炮弹的数量。

最后k行，每行包括一发炮弹的整数坐标x和y（0≤x<M，0≤y<N），之间用一个空格间隔。

输出格式:
对应输入的k发炮弹，输出共有k行，第i行即第i发炮弹消灭的蚊子数。

输入样例:
5 6
00#00#
000###
00#000
000000
00#000
2
1 2
1 4
输出样例:
0
2
 * */
#include <stdio.h>

int board[20][20];
int M,N;
// 函数处理逻辑 当前坐标 和 杀上力
int bang(int x, int y, int kill){
    if((x>=0 && x<M) && (y>=0 && y<N) && board[x][y]>0){
        board[x][y] -=kill;
        if(board[x][y]<=0){
            // 蚊子死了
            return 1;
        }else{
            return 0;
        }
    }else{
        return 0;
    }
    return 1;
}
int main(int argc, const char * argv[]){
   scanf("%d%d",&M,&N);
   getchar();// 去除换行符
   for(int i=0;i<M;i++){
       for(int j=0;j<N;j++){
           // 给数组赋值：令蚊子的生命力为2;因为如果为1时炮弹没有击中，而是在
           // 炮弹范围内所以让其生命力为2更好计算。
           board[i][j] = getchar() == '0' ? 0:2;
       }
       // 再次读取换行符
       getchar();
   }
   int k;
   scanf("%d",&k);
   
   for(int i=0;i<k;i++){
    // 用来定义大炮打的一泡的落点
       int x,y;
       scanf("%d%d",&x,&y);
       int count=0;
       count += bang(x,y,2);
       count += bang(x-1,y,1);
       count += bang(x,y-1,1);
       count += bang(x,y+1,1);
       printf("%d\n",count);
           
   }
   
	return 0;
}
```

#### 字符串

字符串就是一串字符。

##### 字符串的定义：

**c语言**：“abcdefeg” 或 字符数组

```c
#include <stdio.h>

int main(void) { 
	// c 语言运行时内存有四个部分: 栈，堆，常量区，代码块
	char *str ="hello world";
	printf("%s\n",str);
	printf("%p\n",str);
	char *str2 ="hello world";
    printf("%s\n",str2);
	printf("%p\n",str2);
	
	// 这的是s3放到了堆栈里了
	char s3[] = "hello";
	printf("%s\n",s3);
	printf("%p\n",s3);
	
	// s4数组是将常量池中的拿过来
	char s4[] = "hello word";
	printf("%s\n",s4);
	printf("%p\n",s4);
	printf("%d\n",sizeof(s3));
	return 0;
}
// 输出：
hello world
0x402004
hello world
0x402004
hello
0x7fffc8a4589a
hello word
0x7fffc8a4588f
6
可以看到 *str 与*str 两个字符的指针指向的位置相同。
```

**c++**

```c++
#include <iostream>
using namespace std;

int main() {
    string name;
    
	cout  << name <<"\n"; // 什么都没有是空字符串
	
	string name2="llk";
	
	cout  << name2 <<"\n"; 

	return 0;
}
```

**java**

```java
public void name(){
	String name ="张三";
	System.out.println(name);
	// java一般都是new出来的而这个却可以直接复值；
	// String name = "zhang" 这个其实就是在常量池中创建了一个对象，然后name引用指向常量池； 等价于 char data[] = {'z','h','a','n',y};
	String namestr= new String(data);
	// String name = new String("zhang");
	// 这个是在堆栈中创建一个新的对象将“zhang”放到静态区
}
String str="hello";//直接赋值的方式，先在栈中创建一个对String类的对象的引用变量str,然后查找栈中有没有存放“hello”，如果没有就将“hello”存放在栈，并令star指向“hello”,如果已经有“hello”直接令str指向“hello”

通过构造方法创建字符串对象是在堆内存
String str=new String("hello");//实例化的方式

1）直接赋值（String str = "hello"）：只开辟一块堆内存空间，并且会自动入池(到常量池中)，不会产生垃圾。

2）构造方法（String str=  new String("hello");）:会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池(到常量池中)，需要通过public  String intern();方法进行手工入池(到常量池中)。new的每次都会创建对象，他只会存在堆中，每次调用一次就会创建一个新的对象。 将“hello”放到静态区

在开发的过程中不会采用构造方法进行字符串的实例化。
```

##### 正则表达式与串的匹配

正则表达式是用于对字符串的匹配。

##### 自动机

- 非确定型有限状态自动机(NFA):
- 确定型有限状态自动机(DFA):

```java
// C++;

#include <iostream>
using namespace std;
#include <regex>
int main() {
    string str ="abcd";
    regex r("[a-z]+"); // 匹配一个或多个字母
    string email = "abc123@123.xm";
    regex r1("[a-z0-9]+@[a-z0-9]+\\.[a-z0-9]+");
    bool x=regex_match(str,r);
    cout << x <<endl;

    cout << regex_match(email,r1) << endl;
	return 0;
}
// java 使用类 pattern类
pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数

public static void main(String args[]){
      String content = "I am noob " +
        "from runoob.com.";
 
      String pattern = ".*runoob.*";
 
      boolean isMatch = Pattern.matches(pattern, content);
      System.out.println("字符串中是否包含了 'runoob' 子字符串? " + isMatch);
 }
 
// python
import re;
re(r"正则表达式","匹配的字符")
```

### 线性结构

#### 什么是线性结构：

**线性结构的定义**：

**若结构是非空有限集，则有且仅有一个开始结点和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继**  可表示为如下图所示。

**线性结构中数据元素之间的关系就是这种“直接前驱”或“直接后继”的相邻关系，可以用一个有序对表示,如：a2与a3的关系：<a2,a3>**

[![Di52Is.png](https://s3.ax1x.com/2020/11/15/Di52Is.png)](https://imgchr.com/i/Di52Is)

**线性结构的特点：**

**①** **只有一个首结点和尾结点；**

**② 除首尾结点外，其他结点只有一个直接前驱和一个直接后继。**

**线性结构包括线性表、堆栈、队列、字符串、数组等等，其中，最典型、最常用的是线性表**

#### 线性表：

是一种最简单的线性结构。简单地说，**是一个有序集合：用数据元素的有限序列表示**

是由n个数据元素(结点) 常常将非空的线性表记为L = (a1,a2,a3,a4,a5... an); 

其中

-  L：是线性表的表名
- n表示数据元素的个数，当n=0时成为空表。表中的数据元素a时一个抽象的符号，成为i在ai在线性表中的位序。

[![DizsV1.png](https://s3.ax1x.com/2020/11/15/DizsV1.png)](https://imgchr.com/i/DizsV1)



##### **线性表四个基本特征：**

**1.集合中必存在唯一的一个“第一元素”；**

**2.集合中必存在唯一的一个“最后元素”；**

**3.除最后元素之外，其它数据元素均有唯一的“直接后继”；**

**4.除第一元素之外，其它数据元素均有唯一的“直接前驱”；**

**线性表的顺序表示又称为**：**顺序存储结构或顺序映像**

##### 线性表的存储

用一组地址连续的存储单元依次存放线性表中的数据元素。**借助元素在存储器中的**相对位置来表示  **数据元素间的逻辑关系**

#### 顺序表

##### 定义：

**顺序表**是线性表的顺序存储表示的简称，它指的是，“用一组**地址连续**的存储单元**依次存放**线性表中的数据元素”，即以“**存储位置相邻**”表示“位序相继的两个数据元素之间的前驱和后继的关系

>(有序对<ai-1，ai)”，并以表中第一个元素的存储位置作为线性表的起始地址，称作**线性表的基地址**

**顺序存储定义：** 把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构

**顺序存储方法：**用一组地址连续的存储单元依次存储线性表的元素，可通过数组V[n]来实现

**顺序表的类型定义：**

```c
#define  MAXSIZE 100     //最大长度
typedef  struct {
  ElemType  *elem;     //指向数据元素的基地址
  int  length;          //线性表的当前长度                                                      
 }SqList；
```

**顺序表存储结构定义：**

```c
#define MAXSIZE 10000	//图书表可能达到的最大长度 
typedef struct			//图书信息定义
{ 
   char no[20];			//图书ISBN
   char name[50];		//图书名字
   float price; 			//图书价格
}Book; 
typedef struct
{ 
   Book *elem;	//存储空间的基地址 
   int length;		//图书表中当前图书个数 
}SqList;		//图书表的顺序存储结构类型为SqList

```

##### **顺序表的特点：**

**（1）利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与存储结构一致**

**（ 2 ）在访问线性表时，可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为， 访问每个元素所花时间相等**　

##### **顺序表的优缺点:**

**优 点：**

1. **存储密度大 （结点本身所占存储量 / 结点结构所占存储量）**
2. **可以 随机存取 表中任一元素**

**缺点：**

1. **在插入、删除某一元素时，需要移动大量元素**
2. **浪费存储空间**
3. **属于静态存储形式，数据元素的个数不能自由扩充**

**c语言动态分配函数：**

**malloc(m)：开辟m字节长度的地址空间，并返回这段空间的首地址**

**sizeof(x)：计算变量x的长度**

**free(p)：释放指针p所指变量的存储空间，即彻底删除一个变量**

##### 实现线性表

###### C语言

[![DiHTUg.png](https://s3.ax1x.com/2020/11/15/DiHTUg.png)](https://imgchr.com/i/DiHTUg)

代码：

```c
#include <stdio.h>

#define MAX 10

// 使用结构体
struct Slist{
    int data[MAX];
    int length;
};
// 初始化
void init(struct Slist* p){
    p->length =0;
}
// 打印
void printList(const struct Slist* p){
    for(int i=0;i<p->length;i++){
        printf("%d",p->data[i]);
    }
    putchar('\n');
    
}
// 插入
int insert(struct Slist* p, int k, int x){
    // 判断插入的位置
    if(k<0 || k> p->length || p->length==MAX-1) return 0; // 表示失败
    for(int i=p->length-1;i>=k;i++){
        // 元素向后挪一位
        p->data[i+1] = p->data[i];
    }
    p->data[k] = x;
    p->length++;
    return 1;
    
}

// 删除
int delete1(struct Slist* p, int k, int *px){
    if(k<0 || k >= p->length) return 0;
    else {
        *px = p->data[k];
        for(int i= k+1; i<p->length;i++){
            p->data[i-1] = p->data[i];
        }
        p->length--;
        return 1;
    }
}
int main(void) { 
    struct Slist a;
    init(&a);
    // 插入 在0号元素插入x
    int k=0,x=11;
    insert(&a,k, x);
    
    // 删除并将返回删除的值的地址。
    int addr;
    delete1(&a, 1,&addr);
    // 这里传入a的话就会copy一份数组了，所以这里使用地址进行传入
    printList(&a);
	return 0;
}
```

###### c++

```c++
#include <iostream>
#include <list>
#include <vector>
#include <stack>
using namespace std;
int main(int argc ,const char * argv[]) {
   vector<int> v;
   v.push_back(11);
   v.push_back(12);
   v.push_back(13);
   // 使用迭代器
   vector<int> ::iterator it;
   for(it=v.begin(); it!=v.end();it++){
       cout<< *it << ",";
   }
   cout << endl;
    // 插入
   v.insert(v.begin(),666); // 在 0 号位置进插入
   v.insert(v.begin()+2, 333); // 在 2号位置进行插入
    // 删除
   v.erase(v.begin()+1); // 
   for(int i:v){
       cout << i << ",";
   }
    
   cout << endl;
	return 0;
}
```

###### **java**

```java
public void testArrayList(){
    ArrayList<Integer> list = new ArrayList<>();
   	list.add(123);
    list.add(234);
    // 在1号位置插入
    list.add(1,666);
    // 移除某个下标的。返回删除的元素
    int k=list.remove(2);
    
}
// 实现自己的顺序表
package com.java1995;

public class ArrayList {
	//定义Object[]数组；
	private Object[] objs;
	
	public 	ArrayList(){
		//初始容量
		objs=new Object[10];
	}
	public ArrayList(int size){
		objs=new Object[size];
	}
	//增加的方法
	public boolean add(Object obj){
		int index=-1;
		for(int i=0;i<objs.length;i++){
			if(objs[i]==null){//未放数据；
				index=i;
				break;
			}
		}
		if(index==-1){//要扩容；
			int oldlen=objs.length;
			//创建新的数组；
			Object[] objs2=new Object[objs.length*2];
//			老数组的数据复制到新的数组中；
			System.arraycopy(obj, 0, objs2, 0, objs.length);
			objs=objs2;
			objs[oldlen]=obj;
		}else{
			objs[index]=obj;
		}
		return true;
	}
	//删除的方法；
	public Object remove(int index){
		Object obj=objs[index];
		objs[index]=null;
		return obj;
	}
	//修改的方法；
	public Object set(int index,Object newobj){
		Object oldobj=objs[index];
		objs[index]=newobj;
		return oldobj;
		
	}
	//查找的方法；
	public Object get(int index){
		return objs[index];
	}
	@Override
	public String toString() {
		StringBuffer sb=new StringBuffer();
		//sb.append("[");
		for(Object obj: objs){
			if(obj==null)continue;
			sb.append(obj+" ");
		}
		//sb.append("]");
		return sb.toString();
	}
	
}

```

###### **Python**

```python
a=list();
a.append(11);
a.append(222);
# 插入
a.insert(3,33);
# 删除 用栈的方式弹出
a.pop(1);
```

#### 链表：

链表：n个结点由指针链组成一个链表，它是线性表的链式存储映像。称为线性表的链式存储结构。

链表的结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相等。链表对空间上有一定的要求，因为他的存储很可能分布在不同的位置。

链式存储结构：

[![D823Dg.png](https://s3.ax1x.com/2020/11/22/D823Dg.png)](https://imgchr.com/i/D823Dg)

链表各个**结点**由两个域组成，**数据域与指针域**  

- 数据域： 存放元素数值数据

- 指针域：存放直接后继结点的存储位置。

  ​	

[![DX5lTA.png](https://s3.ax1x.com/2020/12/06/DX5lTA.png)](https://imgchr.com/i/DX5lTA)

**头指针** 是指向链表中第一个结点的指针

**首元结点** 是指链表中存储第一个数据元素a1的结点

**头结点**  是在链表的首元结点之前附设的一个结点；数据域内只放空表标志和表长等信息

[![DX5rYq.png](https://s3.ax1x.com/2020/12/06/DX5rYq.png)](https://imgchr.com/i/DX5rYq)

   **有头结点时，**当头结点的指针域为空时表示空表

**设置头节点的好处**

**⒈** **便于首元结点的处理**

**首元结点的地址保存在头结点的指针域中****

**⒉**便于**空表和非空表**的统一处理

**无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了**

**头结点的**数据域可以为空，也可存放线性表**长度**等附加信息，但此结点不能计入链表长度值。



##### 链表分类：

单链表：结点只有一个指针域的链表

双链表：结点有两个指针域的链表

循环链表：首尾相接的链表称为循环链表
[![D8I1Wd.png](https://s3.ax1x.com/2020/11/22/D8I1Wd.png)](https://imgchr.com/i/D8I1Wd)

##### 链表的特点：

- **结点在存储器中的位置是 任意 的，即 逻辑上相邻的数据元素在物理上不一定相邻**
- **访问时只能通过头指针进入链表，并通过每个结点的指针域向后扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等**

##### 链表的优缺点：

**优点**

- ​	–**数据元素的个数可以自由扩充**
- ​	–**插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高**

**缺点**

​	•      **存储密度小**

​	•      **存取效率不高，必须采用 顺序存取 ，即存取数据元素时，只能按链表的顺序进行访问 （顺藤摸瓜）**

#### 单链表：

#####  定义

[![DG9OMV.png](https://s3.ax1x.com/2020/11/22/DG9OMV.png)](https://imgchr.com/i/DG9OMV)

**单链表是由表头唯一确定，因此单链表可以用头指针的名字来命名**

**若头指针名是**L**，则把链表称为表**L 

##### 链表的操作

**求表长**：数结点，指针p依次指向各个结点，从第一个结点一直数到最后一个结点。

```
L->next === 就是看L的next是否有元素，
p=L->next; // p指向第一个结点
i=0;
while(p){i++;p=p->next}
这的p到最后一个结点后p==null了

int  ListLength_L(LinkList L){
//返回L中数据元素个数
    LinkList p;
    p=L->next;  //p指向第一个结点
     i=0;             
     while(p){//遍历单链表,统计结点数
           i++;
           p=p->next;    } 
    return i;                             
 }

```

**取值：** 链表的查找要从链表的头指针出发，顺着链域next逐个结点往下搜索，直至搜索到第i个结点为止，因此链表不是随机存取结构。

**从第 1 个结点（ L->next ）顺链扫描，用指针 p 指向当前扫描到的结点， p 初值 p** **=** **L->next 。**

**j 做计数器，累计当前扫描过的结点数， j 初值为 1 。**

**当 p 指向扫描到的下一结点时，计数器 j 加 1 。**

**当 j = i  时 p  所指的结点就是要找的第  i  个结点**

```c
//获取线性表L中的某个数据元素的内容
Status GetElem_L(LinkList L,int i,ElemType &e){ 
    p=L->next;j=1; //初始化
     while(p&&j<i){	//向后扫描，直到p指向第i个元素或p为空 
       p=p->next; ++j; 
     } 
     if(!p || j>i)return ERROR; //第i个元素不存在 
     e=p->data; //取第i个元素 
     return OK; 
}//GetElem_L 

```

**查找**:根据指定数据获取数据所在的位置。

**从第一个结点起，依次和  e  相比较。**

**如果找到一个其值与  e  相等的数据元素，则返回其在链表中的  “  位置  ”或地址  ；**

**如果查遍整个链表都没有找到其值和 e相等的元素，否则返回0或 “NULL”**

```c
//在线性表L中查找值为e的数据元素
LNode *LocateELem_L (LinkList L，Elemtype e) {
 //返回L中值为e的数据元素的地址，查找失败返回NULL
  p=L->next;
  while(p &&p->data!=e)  
        p=p->next;                		
  return p; 	
} 

//在线性表L中查找值为e的数据元素
int LocateELem_L (LinkList L，Elemtype e) {
 //返回L中值为e的数据元素的位置序号，查找失败返回0 
  p=L->next; j=1;
  while(p &&p->data!=e)  
        {p=p->next;  j++;}          		
  if(p) return j; 
  else return 0;
} 

```

**插入**

•**将值为  x  的新结点插入到表的第  i  个结点的位置上，即插入到  a  i-1  与  a  i  之间**

[![DGCqFH.png](https://s3.ax1x.com/2020/11/22/DGCqFH.png)](https://imgchr.com/i/DGCqFH)

**s->next=p->next;      p->next=s**

**（ 1  ）找到  a  i-1  存储位置  p**

**（  2  ）生成一个新结点  *s**

**（  3  ）将新结点 *s  的数据域置为  x**

**（  4  ）新结点 *s  的指针域指向结点  a  i**

**（  5  ）令结点  *p  的指针域指向新结点 *s**

```c
Status ListInsert_L(LinkList &L,int i,ElemType e){ 
     p=L;j=0; 
      while(p&&j<i−1){p=p->next;++j;}	//寻找第i−1个结点 
      if(!p||j>i−1)return ERROR;	//i大于表长 + 1或者小于1  
      s=new LNode;			//生成新结点s 
      s->data=e;      		           //将结点s的数据域置为e 
      s->next=p->next;	   	          //将结点s插入L中 
      p->next=s; 
      return OK; 
}//
```

**删除：**

[![DGP8pR.png](https://s3.ax1x.com/2020/11/22/DGP8pR.png)](https://imgchr.com/i/DGP8pR)

**（  1  ）找到  a  i-1  存储位置  p**

**（  2  ）保存要删除的结点的值**

**（  3  ）令  p-  ＞  next  指向  a  i  的直接后继结点**

**（  4  ）释放结点  a  i  的空间**

```c
//将线性表L中第i个数据元素删除
 Status ListDelete_L(LinkList &L,int i,ElemType &e){
    p=L;j=0; 
    while(p->next &&j<i-1){//寻找第i个结点，并令p指向其前驱 
        p=p->next; ++j; 
    } 
    if(!(p->next)||j>i-1) return ERROR; //删除位置不合理 
    q=p->next; //临时保存被删结点的地址以备释放 
    p->next=q->next; 	//改变删除结点前驱结点的指针域 
    e=q->data; 	//保存删除结点的数据域 
    delete q; 	//释放删除结点的空间 
 return OK; 
}
```

##### 链表操作实现：

###### C语言

```c
#include <stdio.h>

#include<malloc.h>

// 两种形式的链表：

// 头指针  插入 删除 会有影响 影响指针 

struct Node{
    int data; // 
    struct Node* next; // 下一个的指针
};
 
// 从新定义为 把结构体 指针 去一个别名
// typedef struct Node* LList

// 这个地方是取指针的指针（因为是传的地址）
void init(struct Node** phead){
    *phead =NULL;
}

int getLength(struct Node* head) {
    int len=0;
    // 从头结点一直往后找
    while(head){
        len++;
        head=head->next;
    }
    return len;
}

// 这边是传的指针的值，并不会改变指针
void printlist(struct Node* head){
    while(head){
        printf("%d,",head->data);
        head = head->next;
    }
}
// 创建结点
struct Node* createNode(int x){
    struct Node* t;
    t = (struct Node*)malloc(sizeof(struct Node));
    t->next=NULL;
    t->data =x;
    return t;
}

// 查找元素 第k个 返回 地址
struct Node* findEle(struct Node* phead,int k){
    struct Node* p; // 定义一个指针
    int count=1; // count初值
    p=phead; // 执向的第一个位置
    // 判断p是不是空，计数器不为空
    while(p && count<k){
        p= p->next;
        count++;
    }
    return p;
}

// 插入
// 指针的指针
int insert(struct Node** phead, int k, int x){
     // 找k 就去找k-1的位置，
   
    if(k<1){
        return 0;
    }
    if(k==1){
        // 当插入的是第一个位置的时
        struct Node* t;
        t=createNode(x);
        t->next=*phead;
        *phead= t;
        return 1;
    }
    // struct Node* p; // 定义一个指针
    // int count=1; // count初值
    // p=*phead; // 执向的第一个位置
    // // 判断p是不是空，计数器不为空
    // while(p && count<k-1){
    //     p= p->next;
    //     count++;
    // }
    // 代替上面的
    struct Node* p;
    // zhaok是取找k-1个
    p=findEle(*phead,k-1);
    
    if(p){
         struct Node* t;
        // t = (struct Node*) malloc(sizeof(struct Node));  //创建结点
        t = createNode(x);
        t->next=p->next; // p原先的下一个，让 t的下一个给指向
        p->next =t;
        return 1;
    }else {
        return 0;
    }
}

// 删除

int removeNode(struct Node** phead, int k, int *px){
    // 需要区分头和是不是头
    if(k<1){
        return 0;
    }else if(k==1){
        if(*phead){
            // 头指针不为空，
            *px = (*phead)->data;
            *phead=(*phead)->next;
            return 1;
        }else{
            return 0;
        }
    }else{
        struct Node* p;
        p=findEle(*phead, k-1);
        if(p == NULL || p->next == NULL){
            // 当前为空 ，下一个为空
            return 0;
        }
        struct Node* t;
        t=p->next;
        p->next = t->next;
        *px = t->data;
        free(t); // 释放内存
        return 1;
        
    }
}
// 头结点 两种方式。 插入删除 不会影响指针 ，只是会影响 头结点的next的指针域（值） 



int main(void) { 
    
    struct Node* head; // 链表的头指针
    // 创建一个空链表
    init(&head); // 传地址 
    
    int k=getLength(head);  // 传递的头指针的值
    printf("%d\n",k); // &k 是取的地址。
    int flag=0;
    flag = insert(&head,1,11); // 这里应该传入头指针的地址 在 1号位置插入 11
    flag = insert(&head,1,21);
    flag = insert(&head,1,31);
    
    printf("%d\n",flag);
    
    printlist(head);
    
    int x;
    
    removeNode(&head, 1, &x); //传递的头指针地址
    
    printlist(head);
    
	return 0;
}
```

###### C++

```c++
#include <iostream>
using namespace std;
#include <list>
#include <vector>
#include <stack>
int main() {
    list<int> a;
    a.push_back(11);
    a.push_back(22);
    a.push_back(33);
    a.insert(a.begin(),666);
    for(int i :a ){
        cout << i <<",";
    }
    
    
    // a.erase() // 删除
    // 这个是通过it++相当于 p.next
    list<int>:: iterator it;
    for(it=a.begin(); it!=a.end(); it++){
        cout << &(*it) << "," << *it <<endl;
    }
	return 0;
}
```

###### java

```java
java实现的其实是个双向链表
    public  void test(){
        LinkedList<Integer> linkedList = new LinkedList <>();
        linkedList.add(1);
        linkedList.add(2);
        linkedList.add(4);
        linkedList.clear(); // 清空
        System.out.println(linkedList.get(2));
        System.out.println(linkedList);
    }
// 用java 实现单链表、

package com.kaysanshi.testArray;
/**
 * 链表：是由每个结点和结点数据所组成的链表
 * @author kaysanshi
 *@date 2019年4月25日
 */
public class LinkList {
	//链表的头结点
	private Node first;
	
	public LinkList(){
		first=null;
	}
	/**
	 * 插入节点：在头结点后进行插入
	 * @param value
	 */
	public void insert(long value){
		Node node=new Node(value);
			//把下一个节点的指向添加的节点
			node.next=first;
			//然后把值给first
			first=node;
		
	}
	/**
	 * 删除一个节点，删除的第一个节点
	 * @return
	 */
	public Node deleteFisrt(){
		//把下一个节点给接受
		Node temp=first;
		//然后把这个节点指向第一个节点
		first=temp.next;
		return temp;
	}
	/**
	 * 显示的方法
	 */
	public void display(){
		Node current=first;
		//当前的节点不为null
		while(current!=null){
			current.display();
			current=current.next;
		}
	}
	/**
	 * 查找
	 * @param value
	 * @return
	 */
	public Node find(long value){
		Node current=first;
		while(current.data!=value){
			//下一个没有了终止
			if (current.next==null) {
				return null;
			}
			//指向下一个元素
			current=current.next;
		}
		return current;
	}
	/**
	 * 删除的方法：返回删除的数据
	 * @param value
	 * @return
	 */
	public Node delete(long value){
		//当前的节点
		Node current=first;
		//前一个节点
		Node previous=first;
		while(current.data != value){
			if (current.next==null) {
				return null;
			}
			previous=current;
			current=current.next;
		}
		if (current==first) {
			
			first=first.next;
			
		}else{
			
			previous.next=current.next;
		}
		return current;
	}
}
/**
 * 这是每个节点域
 * @author kaysanshi
 *@date 2019年4月25日
 */
class Node{
	//数据域
	public long data;
	
	//结点域
	//指针域
	public Node next;
	
	//前一个指针域
	public Node privious;
	
	public Node(long value){
		this.data=value;
	}
	/**
	 * 显示的方法
	 */
	public void display(){
		System.out.println(data+" ");
	}
}

```

###### python

python直接使用list就可以了。

####  循环链表：

循环链表：首尾相接的链表称为循环链表

##### 单项循环链表

###### java实现单项循环链表

```java
package com.kaysanshi.testArray;

/**
 * 单链表 循环链表
 * @Author kay三石
 * @date:2020/12/6
 * 对于循环链表而言，关键要素是指定链表的头节点head、尾节点tail以及链表大小size；
 * 该数据结构支持在头部增加节点、在尾部增加节点，从头部删除节点及从尾部删除节点等
 */
public class LinkedListSingleList {
    // 使用的是Node节点

    /**
     *  //数据域
     * 	public long data;
     *
     * 	//结点域
     * 	//指针域
     * 	public Node next;
     *
     * 	//前一个指针域
     * 	public Node privious;
     *
     * 	public Node(long value){
     * 		this.data=value;
     *  }
     */
    private Node head; // 头节点

    private Node tail; // 尾节点

    int size;

    public LinkedListSingleList(){
        this.tail = this.head = null;
        this.size = 0;
    }

    /**
     * 从链表头部增加节点
     * @param node
     */
    public void addNodetoHead(Node node) {
        // 如果使用该方法增加链表的第一个节点，则head=tail=node，且next指向自身
        if(size==0){
            //
            node.next = node;
            tail =head =node;
            size++;
        }else{
            tail.next = node;
            node.next=head;
            size++;
        }
    }

    /**
     * 从链表的尾部增加节点
     * @param node
     */
    public void addNotetoTail(Node node){
        //如果使用该方法增加链表的第一个节点，则tail=head=node，且next指向自身
        if(size==0){
            //
            tail.next = node;
            tail=head=node;
            size++;
        }else{
           tail.next = node;
           node.next = head;
           tail = node;
           size++;
        }
    }

    //删除头部节点，被删掉的head将被自动回收
    public void delHead(){
        if(size>1){
            head = head.next;
            tail.next=head;
            size--;
        }
        else if(size==1){
            head = tail = null;
            size--;
        }
        else{
            System.out.println("There is no elements in the linked list.");
        }
    }

    //删除尾部节点
    public void delTail(){
        if(size>1){
            Node node = new Node();
            node = head;
            while(node.next!=tail){
                node = node.next;
            }
            node.next=head;
            size--;
        }
        else if(size==1){
            head = tail = null;
            size--;
        }
        else{
            System.out.println("There is no elements in the linked list.");
        }
    }

    //打印全部节点
    public void printList(){
        Node node = new Node();
        node = head;
        try{
            while(node.next!=head){
                System.out.print(node.data);
                System.out.print("->");
                node = node.next;
            }
            System.out.print(node.data);
            System.out.print("->");
            System.out.print(head.data);
        }
        catch(Exception e){
            e.printStackTrace();
        }

    }

    public static void main(String[] args){
        // TODO Auto-generated method stub
        LinkedListSingleList lst = new LinkedListSingleList();
        Node head = new Node(11);
        Node head2 = new Node(13);
        lst.addNodetoHead(head);
        lst.addNodetoHead(head2);
        System.out.println("打印链表：");
        lst.printList();

        lst.addNotetoTail(new Node(22));
        lst.addNotetoTail(new Node(33));
        System.out.println("打印链表：");
        lst.printList();
        System.out.println();
        System.out.println("删除首端节点：");
        lst.delHead();
        lst.printList();
        System.out.println();
        System.out.println("删除首端节点：");
        lst.delHead();
        lst.printList();
    }
}

```

###### java实现双向循环链表

**获取节点**

> 由于双向链表有两个可见的节点（head和end），因此双向循环链表获取节点的操作和单链表有所不同。

- 把需要获取的节点序号和链表长度/2比较
- 若小于，说明节点是偏前的，因此从head开始一路next下去
- 若大于，说明节点是偏后的，因此从end开始一路prev上去
- 这样的设计能使getNode操作的时间复杂度缩短为O(logN)

**删除元素**

- 获取待删除元素的节点node
- 把node前一个节点的next指针设置为node的后一个节点。具体实现为：node.prev.next=node.next
- 把node后一个节点的prev指针设置为node的前一个节点。具体实现为：node.next.prev=node.prev
- 由于没有指针指向node,node会被自动清理
- 记录链表长度的变量-1

**插入元素**

- 获取待插入元素的节点node
- 创建一个节点mynode，next指向node，prev指向node.prev
- 把node.prev该节点的next指向mynode
- 把node的前一个节点prev指向mynode

**双向循环链表的优劣**

优势

- 相比单链表，双向循环链表所有基本操作均快于单链表(java源码的LinkList类就是双向循环链表)
- 能直接获取节点的前一个节点，十分灵活

劣势

- 相比单链表，双链表的空间内存明显要大很多

> 双链表的设计应用了算法设计的“空间换时间”思想，通过消耗更多的空间来缩小操作的时间复杂度。

```java
package com.kaysanshi.testArray;

/**
 * 双向循环链表
 * 双向循环链表不只是只有头指针head,还有尾结点end
 * @Author kaysanshi
 * @date:2020/12/6
 */
public class LinkedListTwowaycircular {
    /**
     * 这是每个节点域
     *
     * @author leoill
     * @date 2019年4月25日
     * <p>
     * class Node {
     * //数据域
     * public long data;
     * <p>
     * //结点域
     * //指针域
     * public com.kaysanshi.testArray.Node next;
     * <p>
     * //前一个指针域
     * public com.kaysanshi.testArray.Node privious;
     * <p>
     * public Node(long value) {
     * this.data = value;
     * }
     * <p>
     * public Node() {
     * }
     * <p>
     * public Node(long data, com.kaysanshi.testArray.Node next) {
     * this.data = data;
     * this.next = next;
     * }
     * <p>
     * public Node(long data, com.kaysanshi.testArray.Node next, com.kaysanshi.testArray.Node privious) {
     * this.data = data;
     * this.next = next;
     * this.privious = privious;
     * }
     * }
     */

    Node head;
    Node end;
    int size;
    long t;

    //初始化链表
    public void initlist() {
        end = new Node ();
        head = new Node(0, null, end);
        // 这个地方进行初始化的时候是将下个尾节点的next指向头部
        end.privious = head;
        end.next = head;
        size = 0;
    }

    //获取长度
    public int length() {
        return size;
    }

    //获取节点
    public Node  getNode(int index) {
        Node  n;
        // 判断index是否大于中间的
        if (index >= size / 2) {
            // 若大于，说明节点是偏后的，因此从end开始一路prev上去
            n = end;
            // 获取结点的
            for (int i = length(); i > index; i--) {
                n = n.privious;
            }
            return n;
        } else {
            // 若小于，说明节点是偏前的，因此从head开始一路next下去
            n = head;
            for (int i = 0; i <= index; i++) {
                n = n.next;
            }
            return n;
        }
    }

    //添加元素
    public void add(long a) {
        Node renode = new Node(a, getNode(size - 1), end);
        renode.privious.next = renode;
        renode.next.privious = renode;
        size++;
    }

    //插入元素
    public void insert(int i, long a) {
        // 获取待插入元素的节点node
        Node  n = getNode(i);
        // 创建一个节点newnode，next指向node，prev指向node.prev
        Node newNode = new Node (a, n.privious, n);
        // 把node.prev该节点的next指向新的结点
        n.privious.next = newNode;
        // 把node的前一个节点prev指向新的node
        n.privious = newNode;
        size++;
    }

    //删除元素
    public long remove(int i) {
        // 获取待删除元素的节点node
        Node  n = getNode(i);
        long data = n.data;
        // 把node前一个节点的next指针设置为node的后一个节点
        n.privious.next = n.next;
        // 把node后一个节点的prev指针设置为node的前一个节点
        n.next.privious = n.privious;
        // 由于没有指针指向node,node会被自动清理 令其size减一
        size--;
        return data;
    }

    //获取i位置的数据
    public long get(int i) {
        return getNode(i).data;
    }

    //为i位置元素重新赋值
    public long set(int i, long a) {
        Node  n = getNode(i);
        long old = n.data;
        n.data = a;
        return old;

    }

    //清空链表
    public void clear() {
        initlist();
    }


    public void print() {
        for (int i = 0; i < size; i++) {
            System.out.println(getNode(i).data);
        }
    }

    public static void main(String[] args){
        // TODO Auto-generated method stub
        LinkedListTwowaycircular list = new LinkedListTwowaycircular();
        list.initlist();
        list.add(1);
        list.add(2);
        list.print();
    }
}

```



#### 双向链表：

双链表：结点有两个指针域的链表

##### 双向链表的操作

###### **java实现双向链表**

```java
package com.kaysanshi.testArray;
/**
 * 双向链表
 * @author kaysanshi
 *@date 2019年4月26日
 */
public class DoubleLinkList_double {
	//链表的头结点
			private Node first;
			//尾节点
			private Node last;
			
			public DoubleLinkList_double() {
				// TODO Auto-generated constructor stub
				first=null;
				last=null;
			}
			/**
			 * 从头结点后进行插入 要对链表判断，判断是否weinul。如果weinull.则设置尾结点为新添加的结点；，如果不为null
			 * 设置头结点的前一个结点为新添加的结点
			 * @param value
			 */
			public void insert(long value){
				Node node=new Node(value);
				if (isEmpty()) {
					//把尾节点为第一次添加的
					last=node;
				}else{
					first.privious=node;
				}
				node.next=first;
				first=node;
			}
			/**
			 * 从尾节点进行插入：如果链表为null则直接设置头结点为新添加的结点，否则设置尾结点的后一个结点为新添加结点
			 * 同时设置新添加的节点的前一个结点为尾结点
			 */
			public void insertLast(long value){
				Node node=new Node(value);
				if (isEmpty()) {
					first=node;
				}else{
					last.next=node;
					node.privious=last;
				}
				last=node;
			}
			/**
			 * 从头部删除的第一个节点:判断头结点是否有下一个结点，如果没有则设置尾节点为null,否则设置头结点的下一个结点的
			 * previous为null;
			 * @return
			 */
			public Node deleteFisrt(){
				//把下一个节点给接受
				Node temp=first;
				if (first.next == null) {
					last=null;
				}else{
					first.next.privious=null;
				}
				first=temp.next;
				return temp;
			}
			/**
			 * 删除节点 从尾部删除
			 * 判断头结点是否有下一个结点，如果没有则设置头节点为null,否则设置尾结点的下一个结点的
			 * next为null;
			 */
			public Node deleteLast(){
				Node temp=last;
				if (first.next==null) {
					first=null;
				}else{
					last.privious.next=null;
					
				}
				last=last.privious;
				return last;
			}
			/**
			 * 显示的方法
			 */
			public void display(){
				Node current=first;
				//当前的节点不为null
				while(current!=null){
					current.display();
					current=current.next;
				}
			}
			/**
			 * 查找
			 * @param value
			 * @return
			 */
			public Node find(long value){
				Node current=first;
				while(current.data!=value){
					//下一个没有了终止
					if (current.next==null) {
						return null;
					}
					//指向下一个元素
					current=current.next;
				}
				return current;
			}
			/**
			 * 删除的方法：返回删除的数据
			 * @param value
			 * @return
			 */
			public Node delete(long value){
				//当前的节点
				Node current=first;

				while(current.data != value){
					if (current.next==null) {
						return null;
					}
					
					current=current.next;
				}
				if (current==first) {
					
					first=first.next;
					
				}else{
					current.privious.next=current.next;
				}
				return current;
			}
			/**
			 * 判断weinull
			 * @return
			 */
			public boolean isEmpty(){
				return (first==null);
			}
}

```



###### **java实现双端链表**

```java

/*
 * 实现自己的linkedList;双端链表
 */
public class LinkedList {
	private Node head;//头结点
	private Node last;//尾结点;
	private int size;
	//初始化头尾结点；
	public LinkedList(){
		head=new Node();
		last=head;
	}
	//增加的方法；在链表后增加；
	public boolean add(Object obj){
		Node newNode=new Node();
		newNode.setData(obj);
		last.setNext(newNode);
		last=newNode;
		size++;
		return true;
	}
	//删除的方法；
	public Object remove(int index){
		if(index==0){
			head=head.getNext();
			return null;
		}
		Node before=head;
		for(int i=0;i<index;i++){
			before=before.getNext();
		}
		Node current=before.getNext();
		before.setNext(current.getNext());
		current.setNext(null);
		size--;
		return current.getData();
	}
	//按照属性；删除；
//	 public Object remove(Object item){     
//		 Node before=head;
//		 Object beforeObj=head.getData();
//		for(int i=0;i<size;i++){
//			if(item.equals(beforeObj)){
//				beforeObj=before.getNext().getData();
//				}
//				before=before.getNext();
//			}
//			Node current=before.getNext();
//			Object currentObj=before.getNext().getData();
//			before.setNext(current.getNext());
//			current.setNext(null);
//			before.setData(null);
//			size--;
//			return currentObj;
//	    } 
	//插入的方法；
	 public void insert(int index,Object obj){  
	     Node node=head;  
	     int j=0;  
	     while(node!=null&&j<index-2){  
	         //查找到第index-1个元素  
	         node=node.getNext();  
	         j++; 
	     }  
	     Node sert=new Node();//被插入的结点  
	     sert.setData(obj);
	     sert.setNext(node.getNext());  
	     node.setNext(sert);
	     size++;
	 }
	 
	//改变指定位置的元素 
	 public void modify(int index,Object obj){  
	     Node node=head;  
	     int j=0;  
	     while(node!=null&&j<=index){  
	         //找到第index个结点  
	         node=node.getNext();  
	         j++;  
	     }  
	     node.setData(obj);
	 }
	//查找的方法：无效；
	public Object get(Object obj){
		Node current=head;
		Object objs;
		int j=0;
		while(current.getNext()!=null&&j<=size){
				objs=current.getNext().getData();
				j++;
			if(obj.equals(objs)){
				System.out.println(obj);
				break;
			}else{
				System.out.println("没有这个数据");
				break;
			}
			
		}
		return current.getData();
	}
	//查找按造下标查找；
//	public void find(int index){
//		Node current=head;
//		for(int i=0;i<index;i++){
//			if(){
//				
//			}
//		}
//	}
	@Override
	public String toString() {
        // StringBuffer线程安全类，方法被synchronized关键字修饰
		StringBuffer sb=new StringBuffer();
		//sb.append("[");
		Node currentNode=head;
		while(true){
			if(currentNode.getNext()!=null){
				currentNode=currentNode.getNext();
				sb.append(currentNode.getData()+" ");
			}else{
//				System.out.println("这是个空链表");
				break;
			}
			
		}
		//sb.append("]");
		return sb.toString();
		
	}
	
}
/*
 * 结点类；
 */
public class Node {
	private Object data;//数据域
	private Node next;//引用，指针域
	public Node() {
		super();
	}
	public Node(Object data, Node next) {
		super();
		this.data = data;
		this.next = next;
	}
	public Object getData() {
		return data;
	}
	public void setData(Object data) {
		this.data = data;
	}
	public Node getNext() {
		return next;
	}
	public void setNext(Node next) {
		this.next = next;
	}

}

```



|                | **顺    序  表**                                             | **链    表**                                              |
| -------------- | ------------------------------------------------------------ | --------------------------------------------------------- |
| **存储空间**   | **预先分配，会导致空间闲置或溢出现象**                       | **动态分配，不会出现闲置或溢出现象**                      |
| **存储密度**   | **不用为表示结点间的逻辑关系而增加额外的存储开销，存储密度等于 1** | **需要借助指针来体现元素间的逻辑关系，存储密度小于 1**    |
| **存取元素**   | **随机存取，时间复杂度为 O(1)**                              | **顺序存取，时间复杂度为 O( *n *)**                       |
| **插入、删除** | **平均移动约表中一半元素，时间复杂度为 O( *n *)**            | **不需移动元素，确定插入、删除位置后，时间复杂度为 O(1)** |
| **适用情况**   | **①** **表长变化不大，且能事先确定变化的范围**   **② 很少进行插入或删除操作，经常按元素序号访问数据元素** | **①** **长度变化较大**   **② 频繁进行插入或删除操作**     |

#### 栈

##### 定义

栈：只能在表的一端（栈顶）进行插入和删除运算的线性表

**逻辑结构：**与线性表相同，任然是一对一关系

**存储结构：**用顺序栈或链栈存储都可以。

**运算规则：**只能在栈顶运算，且访问结点时依照后进先出或者先进后出的原则。

**实现方式：**关键是编写入栈和出栈的函数。

[![DjY1QU.png](https://s3.ax1x.com/2020/12/06/DjY1QU.png)](https://imgchr.com/i/DjY1QU)



##### 顺序栈的表示：

[![DjtbuD.png](https://s3.ax1x.com/2020/12/06/DjtbuD.png)](https://imgchr.com/i/DjtbuD)

```c
#define  MAXSIZE  100
typedef struct{
		SElemType   *base;
		SElemType   *top;
		int stacksize;
}SqStack;

// 初始化
Status InitStack( SqStack &S ){
	S.base =new SElemType[MAXSIZE]；
	if( !S.base ) 	return OVERFLOW;
	S.top = S.base;
	S.stackSize = MAXSIZE;
	return OK;
}
// 顺序栈是否为空
bool StackEmpty( SqStack S ){
	if(S.top == S.base) return true;
   else return false;
}
// 顺序栈的长度
int StackLength( SqStack S ){
	return S.top – S.base;
}
// 清空顺序栈
Status ClearStack( SqStack S ){
	if( S.base ) S.top = S.base;
	return OK;
}
// 销毁顺序栈
Status DestroyStack( SqStack &S ){
	if( S.base )
	{
		delete S.base ;
		S.stacksize = 0;
		S.base = S.top = NULL;
	}
  return OK;
}
// 顺序栈进站
// (1)判断是否栈满，若满则出错
// (2)元素e压入栈顶
// (3)栈顶指针加1
Status Push( SqStack &S, SElemType e){
	if( S.top - S.base== S.stacksize ) // 栈满
        return ERROR; 	
	*S.top++=e;
	return OK;
}
// 顺序进站
// (1)判断是否栈空，若空则出错
// (2)获取栈顶元素e
// (3)栈顶指针减1
Status Pop( SqStack &S, SElemType &e)  
{
	if( S.top == S.base ) // 栈空
        return ERROR; 	
	e＝ *--S.top;
	return OK;
}
// 取顺序栈栈顶元素
// 判断是否空栈，若空则返回错误
// 否则通过栈顶指针获取栈顶元素
Status GetTop( SqStack S, SElemType &e)  {
	if( S.top == S.base )	 return ERROR; 	// 栈空
	e = *( S.top – 1 );
	return OK;
}




```

##### 顺序栈的操作

###### c语言

```c
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

struct Stack{
    int *data; // 数据
    int capacity;// 最大容量
    int top;// 栈顶
};
// 判断栈满
int isFull(const struct Stack *ps){
    // 满就是top是否与capacity相同
    return ps->top == ps->capacity; 
}
// 判断栈空
int isEmpty(const struct Stack *ps){
    // top为0是空栈
    return ps->top == 0;
}
// 
int top(const struct Stack *ps){
    if(isEmpty(ps)) return 0;
    else{
        *ps = ps->data[--(ps->top-1)];
    	return 1;
    }
    
}
// init
void init(struct Stack *ps,int capacity){
    ps->capacity = capacity; // 初始化容量
    ps->data = (int *)malloc( sizeof(capacity));
    // ps->top = -1; // 总是指向最高元素 
    ps->top = 0; // 总是指向最高元素的上面的空格
}
// 压栈
int push(struct Stack *ps, int x){
    // 判断栈满
    if(isFull(ps)) return 0;
    else{
        // 进行压栈
        ps->data[ps->top++]=x;
        return 1;
    }
    
}
// 弹栈
int pop(struct Stack *ps, int x){
    if(isEmpty(ps)) return 0;
    else{
     *ps = ps->data[--(ps->top)];
      return 1;   
    }
    
}
// 销毁
void destory(struct *ps){
    free(ps->data);
}
int main(void) { 
    struct Stack st;
    
    init(&st，5); // 改变st的内容，所以需要st地址 &st 
    
    push(&st, 11); // 压栈
    push(&st, 121); // 压栈
    push(&st, 111); // 压栈
    push(&st, 131); // 压栈
    int x;
    pop(&st, &x); // 弹栈 并把弹出的数据返回
    
    destory(&st);
    
	return 0;
}
```

###### C++

```c++
#include <iostream>
#include <stack>
using namespace std;
int main(int argc,const char * args[]){
	stack<int> st;
	st.push(11);
	st.push(12);
	int x = st.top();
	st.pop()//弹栈
	st.empty();
    cout << st.size() << endl;
	return 0;
}
```

###### java

```java

public class ArrayStackDemo {
	public static void main(String[] args) {
		//测试
		ArrayStack stack =new ArrayStack(4);
		String key="";
		boolean loop = true;
		Scanner scanner = new Scanner(System.in);
		
		while(loop) {
			System.out.println("show:表示显示栈");
			System.out.println("exit:退出程序");
			System.out.println("push:表示添加数据到栈（入栈）");
			System.out.println("pop:表示从栈取出数据（出栈）");
			System.out.println("请输入你的选择");
			key = scanner.next();
			switch(key) {
			case "show":
				stack.list();
				break;
				
			case "push":
				System.out.println("请输入一个数");
				int value = scanner.nextInt();
				stack.push(value);
				break;
				
			case "pop":
				try {
					int res = stack.pop();
					System.out.printf("出栈的语句是%d\n", res);
				}catch(Exception e) {
					System.out.println(e.getMessage());
				}
				break;
				
			case "exit":
				scanner.close();
				loop = false;
				break;
			default:
					break;
			}
		}
		System.out.println("程序退出");
	}
 
}
 
class ArrayStack{
	private int maxSize;
	private int[] stack;
	private int top = -1;
	
	
	public ArrayStack(int maxSize) {
		this.maxSize=maxSize;
		stack = new int[this.maxSize];
		
	}
	
    //栈满
	public boolean isFull() {
		return top == maxSize -1;
		
	}
    //栈空
	public boolean isEmpty() {
		return top == -1;
		
	}
	//出栈
	public void push(int value) {
		if(isFull()) {
			System.out.println("栈满");
		}
		top++;
		stack[top] =value;
		}
	//出栈
	public int pop() {
		if(isEmpty()) {
			throw new RuntimeException("栈空");
		}
		int value = stack[top];
		top--;
		return value;
	}
	//遍历栈
	public void list() {
		if(isEmpty()) {
			System.out.println("栈空，没有数据");
			return;
		}
		for(int i = top;i>=0;i--) {
			System.out.printf("stack[%d]=%d\n",i,stack[i]);
		}
	}

```

######  python

```python
st = list()
st.append(11)
st.append(22)
st.append(33)
x = st.pop(1) // 弹出1号元素
st.pop() // 弹出最后一个进栈的

```

##### 后缀式求值

后缀式 3 5 2 1 - * + 思路 就是需要一个栈

```python
class Solution:
    def cal(x,y,op):
        if op=='+':
            return x+y
        elif op == '-':
            return x-y
        elif op == '*':
            return x*y
        elif op == '/':
            return x/y

    def evalRPN(self, tokens: List[str]) -> int:
            """
        :type tokens: List[str]
        :rtype: int
        """
        for i in tokens:
            if i in '+-*/':
                b = tokens.pop()
                a = tokens.pop() 
                tokens.append(cal(a,b,i))
            else:
                tokens.append(float(i))
        print('%.1f' % tokens.pop())
        
        
```

```java
class Solution {
    public int evalRPN(String[] tokens) {
    String operators = "+-*/";
        Stack<Object> stack = new Stack<>();
        for(int i=0;i<tokens.length;i++){
            String op = tokens[i];//取出一个操作
            if(operators.contains(op)){//如果是操作符
                int n2 = (int) stack.pop();
                int n1 = (int) stack.pop();
                int value = 0;
                switch (op){
                    case "+":value = n1 + n2;break;
                    case "-":value = n1 - n2;break;
                    case "*":value = n1 * n2;break;
                    case "/":value = n1 / n2;
                }
                stack.push(value);//把值送入栈
            }
            else {//如果是操作数
                stack.push(Integer.valueOf(op));//操作数入栈
            }
        }
        return (int) stack.pop();//最后栈顶的操作数就是运算结果了
    }
}
```



#### 队列

##### 定义

**队列是一种先进先出(FIFO)的线性表**.**在表一端插入在另一端删除**

只能在表的一端（队尾）进行插入，在另一端（队头）进行删除运算的线性表

**逻辑结构：**与线性表相同，任为一对一关系。

**存储结构：**用顺序队列或链队存储均可。

**运算规则：**先进先出FIFO

**实现方式：**关键是编写入队和出队函数，具体实现实现依顺序队或的不同而不同。

##### 队列的操作

###### C语言

```

```



#### 循环队列

##### 循环队列的定义

##### 循环队列的操作

###### C语言

```c
#include <stdio.h>
#include <stdlib.h>
struct Queue{
int *data
int capacity; //容量
int front; // 队头
int rear; // 队尾
}
// 指定容量,初始话数据
void init(struct Queue *pq,int capacity){
    pq->capacity = capacity;
    pq->data=(int*)malloc(sizeof(int)*(capacity+1));
    // 初始队头和队尾
    pq->front=pq->rear=0;
}
//队是否满
int isFull(const struct Queue *pq){
    // 取余操作 循环
    if((pq->rear+1)%(pq->capacity+1) == pq->front) return 1;
    else return 0;
}
int isEmpty(const struct Queue *pq){
    return pq->front == pq->rear;
}
//入队
int enQueue(struct Queue *pq,int capacity){
    if(isFull(pq)) return 0;
    else{
        pq->data[pq->rear]=x;
        pq->rear =(pq->rear+1) % (pq->capacity+1);
        return 1;
    }
}
//出队e
int delQueue(struct Queue *pq, int *px){
    if(isEmpty(pq)) return 0;
    else{
        *px = pq->data[pq->front];
        pq->front = (pq->front+1)%(pq->capacity+1);
        return 1;
    }
}
int main(){
    struct Queue q;
    init(&q,5);
    // 入队
    enQueue(&q,11);
    // 出队
    int x;
    delQueue(&q,&x);
    return 0;
}
```

###### C++

```c++
#include <isostream>
using namespace std;
struct Node{
    int data;
    Node* next;
     Node(int x){
        data=x;
        next=NULL;
    }
}
class Queue{
    // 作为一个私有对象
private:    
    Node* front; // 队头
    Node* rear; // 队尾
   
public:
    Queue(){
        //不带空头节点的链表，空指针
        front = real=NULL;
    }
    // 定义一个析构函数释放内存
    ~Queue(){
        Node* tmp;
        while(front){
            tmp = front;
            front=front->next;
            delete tmp;
        }
    }
    bool isEmpty(){
        return front ==NULL; // front为null就是空
    }
    // 入队
    void enQueue(int x){
        Node *tmp;
        tmp=new Node();
        if(isEmpty()){
            cout << "empty" << tmp->data << endl;
            front=rear=tmp;
        }else{
            // 队列不为空时
            rear->next=tmp;
            rear = rear->next; // 等价于 rear = tmp
        }  
    }
    // 出队
    bool delQueue(int *px){
        // 使用指针
        if(isEmpty()) return false;
        else{
            //获取队首元素
            *px= front->data;
            // 把头节点删除
            Node* tmp;
            tmp = front;
            front = front->next;
            delete tmp;
            // 当出队时为null时 则rear也要为null
            if(front==NULL) rear=NULL;
            return true;
        }
    }
}

int main(int argc,const char *argv[]){
    
    return 0;
}
```

###### C++自带的

```c++
#include <isostream>
#include <queue>
using namespace std;
int main(int argc,const char *argv[]){
    queue<int> q;
    q.push(11); // 增加元素
    q.push(12);
    q.pop();// 出队
    int x=q.front();// 查看队首元素
    return 0;
}
```

###### java

```java
public static void main(String[] args){
    // 链表实现了对例的操作
    Queue<Integer> q= new LinkedList<>();
    q.add(11);
    q.add(12);
    q.add(13);
    System.out.println(q.peek());// 查看队首元素
    System.out.println(q.poll());// 出队
}
```

##### 简单模拟单队列排队

**题目**

设某银行有一个固定能容纳N个顾客的等候区，顾客想进银行，若等候区有空则可进，否则被拒绝进入。
每当银行柜员叫号时，等候区中最先进入的顾客离开等候区前往柜台办理业务，若叫号时等候区无人，则此次叫号作废

**输入**

第一行输入一个不大于20的正整数N，表示银行等候区能容纳的人数，
接下来用若干行表示依时间顺序先后发生的“顾客想进银行”或“叫号”事件，格式分别是：

顾客想进银行，用 In 表示，其中是顾客编号，为不大于100000的正整数； 叫号，用Calling表示。
最后一行是一个#符号，表示输入结束。

**输出**

顾客想进银行，若顾客进入，则输出 joined. Total: 其中是该顾客的编号，是顾客进入后，等候区的人数
顾客想进银行，若因等候区满而被拒绝，则输出 rejected. 其中是该顾客的编号 叫号，若有顾客前往柜台，则输出
called. Total: 其中是该顾客的编号，是顾客去柜台后，等候区的人数 叫号，等候区无人，则输出 No
one!

###### C语言

```c
#include <stdio.h>
#include <stdlib.h>
struct Queue{
int *data
int capacity; //容量
int front; // 队头
int rear; // 队尾
int size;
}
// 指定容量,初始话数据
void init(struct Queue *pq,int capacity){
    pq->capacity = capacity;
    pq->data=(int*)malloc(sizeof(int)*(capacity+1));
    // 初始队头和队尾
    pq->front=pq->rear=0;
    pq->size=0;
}
//队是否满
int isFull(const struct Queue *pq){
    // 取余操作 循环
    if((pq->rear+1)%(pq->capacity+1) == pq->front) return 1;
    else return 0;
}
int isEmpty(const struct Queue *pq){
    return pq->front == pq->rear;
}
//入队
int enQueue(struct Queue *pq,int capacity){
    if(isFull(pq)) return 0;
    else{
        pq->data[pq->rear]=x;
        pq->rear =(pq->rear+1) % (pq->capacity+1);
        pq->size++;
        return 1;
    }
}
//出队e
int delQueue(struct Queue *pq, int *px){
    if(isEmpty(pq)) return 0;
    else{
        *px = pq->data[pq->front];
        pq->front = (pq->front+1)%(pq->capacity+1);
        pq->size--;
        return 1;
    }
}
int main(){
   int N;
    scanf("%d",&N);
    struct Queue q;
    init(&q,N);
    char op[20];
    int id;
    scanf("%s",op);
    // 如果op的0号元素不是#
    while(op[0] !='#'){
        if(op[0]=='I'){
            // 如果是IN+id
            scanf("%d",&id);
            if(isFull(&q)){
               // 如果对列满了
                printf("%d rejected.\n",id);
            }else{
                enQueue(&q,id);
                printf("%d joined. Total:%d",id,q.size);
            }
        }else{
            // 如果是Calling+id
            if(isEmpty(&q)){
                printf("No one!\n");
            }else{
                delQueue(&q,&id);
                printf("%d called. Total:%d",id,q.size) 
            }
        }
        scanf("%s",op);
    }
    return 0;
}
```

###### C++

```c++
#include<stdio.h>
#include<iostream>
#include<queue>
#include<string>

using namespace std;
//总体来说，还是简单的题，队列的简单出队和入队操作 
int main(){
	queue<int> q;
	
	int N;
	string str;
	scanf("%d",&N);
	int tem;
    while(getline(cin,str),str !="0"){
    	tem = 0 ; 
    	if(str[0] == '#') break;         // 结束符
    	else if(str == "Calling"){//叫号
			if(!q.empty()){
				tem = q.front();
				q.pop();
				printf("%d called. Total:%d\n",tem,q.size());
			}else{
				printf("No one!\n");
			}	
		}else{
    		for(int i =0;i<str.length();){
    			if(str[0] == 'I' && str[1] == 'n'){//入队
    				i +=2;
    				if(str[i] == ' ')i++;
    				tem = str[i++] - '0';
    
    				while(i<str.length() && str[i] >= '0' && str[i] <= '9'){
    					tem = tem * 10  + (str[i] - '0');
    					i++;
					}
    				if(q.size() < N){
						q.push(tem);
						printf("%d joined. Total:%d\n",tem,q.size());
					}else{
						printf("%d rejected.\n",tem);
					}
    			
				}
			
			}
		}
	}
	return 0;
}

```

###### java

```java
public static void main(String[] args){
    Scanner in = new Scanner(System.in);
    int N= in.next();
    Queue<String> q=new LinkedList();
    String op,id;
    op= in.next();
    while(!op.equals("#")){
        if(op.equals("In")){
            id= in.next();
            if(q.size() == N){
                System.out.println(id+" rejected.");
            }else{
                q.offer(id);
                System.out.println(id+" joined. Total:"+q.size());

            }
        }else{
            if(q.isEmpty()){
                System.out.println("No one!");
            }else{
                id=q.poll();
                System.out.println(id+"called. Total:"+q.size());
            }
        }
        op= in.next();
    }
 in.close();

}
```



#### 链式队列

##### 链式队列的定义



##### 链式队列的操作



### 树

### 优先队列与集合

