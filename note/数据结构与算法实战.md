## 数据结构与算法实战

### 程序的本质

程序是有一系列的机器指令构成。

程序=数据结构+算法

数据结构与算法是相辅相成的。

#### **数据结构：**

数据结构是计算机存储，组织数据的方式。**数据结构是指的相互之间存在一种或多种特定关系的数据元素的集合**。通常情况下精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。

对**处理的问题如何表示**，即问题的**数学模型**是什么

简言之：是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。

<font color="red">“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。</font>

##### 基本术语：

###### 数据(Data)：

​     **在计算机科学中，是指所有**能输入到计算机中并被计算机程序处理的符号的总称（**集合**）  它是对客观事物的符号表示（描述），是计算机处理的信息的特定的符号表示形式（信息的载体）。

​     **数据结构中所讨论数据的范畴很广泛，如：字符、声音、图形、图像等多媒体信息。随着计算机的发展，数据的范畴不断扩大**

比如：

```
struct student{
	long num;
	char name[20];
	char sex;
	char addr[30];
}
struct student s1,s2[6];
```

###### 数据元素(Data Element)

**是数据 ( 集合 ) 中的一个 “ 个体 ” ，在计算机中通常作为一个整体进行考虑和处理。 是数据结构中讨论的 “ 基本单位 ” ， 但不是 最小 单位，它常常有若干 数据项 （ 是对数据元素 不同 属性 的描述 ， 具有 独立的意义 ） 组成 。**

比如：**在学生信息管理系统中， 一条学生纪录 就是 一个数据元素 （学号、姓名、性别等数据项组成）**

| 学号  | 姓名 | 班级    | 地址 |
| ----- | ---- | ------- | ---- |
| s0001 | scd  | class01 | addr |

**数据元素有两类。**

- 一类是不可分割的具有 “原子”型数据元素。如：整数 字符。
- 另一类：由多个款项构成的数据元素（结构型） 其中每个款项被称为一个 “数据项” 是对数据元素某种属性的描述具有独立意义。



###### 关键字

**指能识别一个或多个数据元素的数据项。若能起 唯一 识别作用，则称之为**
**“ 主 ”** **关键字 ，否则称之为“ 次 ”关键字** 比如学号为主关键字。其余为次关键字。

###### 数据对象(Data Object):

是性质相同的数据元素的集合，是数据的一个子集。比如 整数，实数，都是数据的一个子集



[![DiyNp4.png](https://s3.ax1x.com/2020/11/15/DiyNp4.png)](https://imgchr.com/i/DiyNp4)

##### **数据的逻辑结构：**

<font color="red">数据的逻辑结构反应的是数据元素之间的逻辑关系，是指数据元素之间的前后间的关系，而与元素所存储的位置无关</font>。逻辑结构包含：

- 集合：数据结构中的元素之间除了“同一集合”的相互关系外，别无其他关系。
- 线性结构：数据结构中的元素存在一对一的相互关系。
- 树形结构：数据结构中的元素存在一对多党的相互关系。
- 图形结构：数据结构中的元素存在多对多的相互关系。

一般按照逻辑结构分类数据结构可分为：

线性结构：线性结构就是表中各个结点具有线性关系。如果从数据结构的语言来描述，线性结构应该包括如下几点：

- 线性结构是非空集合

- 线性结构有且仅有一个开始结点和一个终端结点。

- 线性结构所有的结点都最多有一个直接前趋结点和一个后继结点。

  包含：线性表，栈，队列，串

非线性结构：线性结构就是表中各个结点具有线性关系。如果从数据结构的语言来描述，线性结构应该包括如下几点：

- 非线性结构是非空集。

- 非线性结构的一个结点可能有多个直接结点和多个后继结点。

  包含：数组，广义表，树结构和图结构

###### 逻辑结构的表示

**数据结构的形式定义为一个二元组：**

​            **Data-Structure=(  D  ，  S)**

**其中：  D  是数据元素的  有限  集，**

​      **S  是  D  上  关系的有限  集。**

> **例  复数的数据结构定义如下  :** **(  复数  x=C1 + C2** **i** **)**
>
> ​           **Complex=(  C  ，  R  )**
>
> **其中：**
>
>   **C  是含两个实数的集合  ﹛  C1  ，  C2  ﹜  ，分别表示复数的  实部  和  虚部  。**
>
>   **R  ={P}  ，  P  是定义在集合上的一种序偶关系：**
>
> ​         **{<C1  ，  C2>}  。  有序对  <>  ,  区别  （）**
>
> **有序对  <  x,y  >  －  y  是  x  的后继，**
> **x  是  y  的前驱：“  相邻  ”**
>
> **一个  <  x,y  >  的  有序对  是构成关系的  基本单位**





##### **数据的物理结构：**

指数据的[逻辑结构]在计算机存储空间的存放形式。

数据的物理结构是数据结构在计算机中的表示（又称映像），它包括数据元素的机内表示和关系的机内表示。由于具体实现的方法有顺序、链接、索引、散列等多种，所以，一种数据结构可表示成一种或多种存储结构。

数据元素的机内表示（映像方法）： 用二进制位（bit）的位串表示数据元素。通常称这种位串为节点（node）。当数据元素有若干个数据项组成时，位串中与各个数据项对应的子位串称为数据域（data field）。因此，节点是数据元素的机内表示（或机内映像）。

关系的机内表示（映像方法）：数据元素之间的关系的机内表示可以分为顺序映像和非顺序映像，常用两种存储结构：顺序存储结构和链式存储结构。顺序映像借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。非顺序映像借助指示元素存储位置的指针（pointer）来表示数据元素之间的逻辑关系。

##### **数据的存储结构：**

数据的逻辑结构在计算机存储空间中的存放形式称为数据的物理结构(也称为存储结构)。一般来说，一种数据结构的逻辑结构根据需要可以表示成多种存储结构，常用的存储结构有顺序存储、链式存储、索引存储和哈希存储等

- **顺序存储结构的特点是：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系；**
- **非顺序存储的特点是：借助指示元素存储地址的指针表示数据元素之间的逻辑关系**

[![DixLu9.png](https://s3.ax1x.com/2020/11/15/DixLu9.png)](https://imgchr.com/i/DixLu9)
[![DixbjJ.png](https://s3.ax1x.com/2020/11/15/DixbjJ.png)](https://imgchr.com/i/DixbjJ)

#### 算法：

算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰[指令]，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的[输入]，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用[空间复杂度]与[时间复杂度]来衡量。

算法中的指令描述的是一个[计算]，当其[运行]时能从一个初始状态和（可能为空的）初始输入开始，经过一系列**有限**而清晰定义的状态，最终产生**输出**并**停止**于一个终态。一个状态到另一个状态的转移不一定是确定的。随机化算法在内的一些算法，包含了一些随机输入。

**特征：**

- 有穷性（Finiteness：算法的有穷性是指算法必须能在执行有限个步骤之后终止；
- 确切性(Definiteness)：算法的每一步骤必须有确切的定义；
- 输入项(Input)：一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；
- 输出项(Output)：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；
- 可行性(Effectiveness)：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算[步骤](https://baike.baidu.com/item/步骤/7066340)都可以在有限时间内完成（也称之为有效性）

**算法的评定：**

- 时间复杂度：算法的时间复杂度是指执行算法所需要的计算工作量。一般来说，计算机算法是问题规模n 的函数f(n)，算法的时间复杂度也因此记做。T(n)=Ο(f(n))
- 因此，问题的规模n 越大，算法执行的时间的增长率与f(n) 的增长率正相关，称作[渐进时间复杂度](https://baike.baidu.com/item/渐进时间复杂度)（Asymptotic Time Complexity）。
- 空间复杂度：算法的[空间复杂度](https://baike.baidu.com/item/空间复杂度/9664257)是指算法需要消耗的内存空间。其计算和表示方法与时间[复杂度](https://baike.baidu.com/item/复杂度)类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。
- 正确性：算法的正确性是评价一个算法优劣的最重要的标准。
- 可读性：算法的可读性是指一个算法可供人们阅读的容易程度。 [1] 
- 健壮性：健壮性是指一个算法对不合理数据输入的反应能力和处理能力，也称为**容错性**

### 函数与递归

为何自己写不出递归呢？

需要 需要确定信念。确定递归的结束条件和递归条件

```java
 /**
     * 递归函数求阶乘
     *
     * @param n
     * @return
     */
    private static int fact(int n) {
        // 递归必须确定结束条件
        if (n < 2) {
            return 1;
        }
        return n * fact(n - 1);
    }

    /**
     * 汉诺塔
     *
     * @param n   盘子数
     * @param src 元盘子
     * @param mid 中间盘子
     * @param tar 目标盘子
     */
    private static void hanoi(int n, int src, int mid, int tar) {
        // 确定结束条件
        if (n == 1) {
            System.out.println(src + "-->" + tar);
        } else {
            hanoi(n - 1, src, tar, mid); // 把n-1个盘子从元盘子借助目标柱子放到中间柱子
            hanoi(1, src, mid, tar); // 把一个盘子从原主借助中间住放到目标住
            hanoi(n - 1, mid, src, tar); // 把n-1个盘子从中间住借助源住放到目标住
        }

    }
```

### 数组与字符串

#### 数组：

##### 数组的定义：

就是线性表的实现。

**c语言**

定义： `int array[N] 或者 int *array = malloc();`

数组的名不是指针。

```c
#include <stdio.h>
#include <stdio.h>
// 这个地方其实是传入的数组的地址 *array，和大小
int func(int *array,int size){
    // array[0] 其实就是指针 array求值得出首地址
	return array[0]; // 等价于 *(array+0);
}
int main(int argc,const char * argv[]){
    // array是一个数组
	int array[100] = {11,22,33,44};
    // 指针的形式
	int *p = malloc(100 * sizeof(int));
    // 在这里是获取到了数组的指针
    printf("%d\n",*(array+1));
    
    // 传入的其实是数组首地址的指针
	printf("%d\n",func(array,100));
	return 0;
}
```

**c++:**

数组定义：`int array[N] 或 int * array = new int[N];`

**java**

数组定义：`int array[] = new int[N];`

```java
public class main{
	public static void main(String[] args){
		int [] array = new int[10];
		array[1]=222;
		array[2]=333;
		System.out.println(array.length);
        ArrayList<Integer> list = new ArrayList<>();
        list.add(123);
        list.add(22);
        System.out.println(list);
	}
}
```

**python**

数组定义： `array = [];`

##### 数组元素的查找：

###### c语言实现：

```c
#include <stdio.h>

/**
** 根据值找到下标
*/
int findX(int * array,int size,int x){
	int flag=0;
	int index=-1;
	for(int i=0;i<size;i++){
		if(array[i]==x){
			flag =1;
			index = i;
		}
	}
	return index;
}
/**
** 根据下标找到值,并把原来的地址给返回过来，并返回状态。
*/
int findElement(int * array,int size, int k, int *px){
    if(k>=size || k<0) return 0;
    else{
        *px=array[k];
        return 1;
    }
}
/**
* 查找最大的。
*/
int findMax(int * array, int size){
    // 是将数组中的一个元素初始为max;
    int max =array[0];
    for(int i=1;i<size;i++){
        if(max<array[i]) max = array[i];
    }
    return max;
}
int main(int argc,const char * argv[]){
	int array[10] = {111,112,33,44,55};
	int x;
	x=12;
	int k;
	k= findX(array,10,x);
	printf("%d\n",k);
    int m,flag;
    // 传入的是数组引用，长度，和下标，和地址
    flag= findElement(array,10,3,&m);
    printf("%d,%d\n",flag,m);
	// 查找最大值
    int max ;
    max = findMax(array,10);
    printf("%d\n",max);
	return 0;
}
```

##### **求两个100位的十进制的和。**

###### C语言实现

```c
int main(int argc, const char * argv[]){
    // 
    // 思路 用数组 ，数组的底位存0号元素(如果0号元素存在高位，则是不可以进位的)
    int a[11] = {0,9,8,7,6,5,4,3,2,1};
    int b[11] = {1,2,3,4,5,6,7,8,9,9};
    int sum[11] = {0};
    int carry=0;//进位操作
    // i< 11是为了计算最后一个
    for(int i=0;i<11;i++){
        int s;
        s=a[i]+b[i]+carry;
        carry = s/10;
        sum[i] = s%10;
    }
    for(int i=10;i>=0;i--){
        printf("%d",sum[i]);
    }
    putchar('\n');
	return 0;
}
```

###### java 实现：

```java
public static void main(String[] args){
	BigInteger a= new BigInteger("12345678");
	BigInteger b= new BigInteger("12345678");
	BigInteger c= a.add(b);
	System.out.println(c);
}
```

#### 二维数组

二维数组的实质：数组的数组。数组中的每一个元素仍然是个数组。

逻辑上可看做二维，其实并不是二维的

**c语言**

`int array [][]  与 int **array`

`int array[3][4];和int **pa 的中的array和pa类型是相同的，但是 pa== array的写法是错误的`

`int array [ ][ ]` 与`int * *`

array是数组的数组。

int *p ===> 是p 指向一个整形变量。

p[2] <==> *(p+2)  就是 p指向的整形变量再+2的位置就是 p[2]

int * * p  因为*靠p元素最近，所以p是一个指针。所以 * * p是指的是指针的指针。`p[1][1]`与 `p[0][1]`的位置截然不同，并不是相差一个 

`int * *p= array是错误的`

```c
#include <stdio.h>

int main(void) { 
	printf("test");
	int array[3][5]; // 是由int[5]
	
	//int *p[5];
	//p =array; // 这样是错误的。
	
	
	int (*p)[5];
	p = array; // 数组名赋值与指针。 那也就是 array是 一个指针。
	
	int a[10];
	int *pa =a // s数组的名求值可获取数组元素的受地址。所以 *pa就是一个指针。
	
	return 0;
}
```

**数组传参：**

```c
#include <stdio.h>
vaid func(int (*)[5] , int ){
    // int (*)[5] 就是一个指向[5]的指针
}
void func(int array[][5] ,int k){
    // int array[][5]==>int (*p) [5];
    
}

int main(void) { 
	printf("test");
	int array[3][5]; // 是由int[5]
	
	//int *p[5];
	//p =array; // 这样是错误的。
	
	
	int (*p)[5];
	p = array; // 数组名赋值与指针。 那也就是 array是 一个指针。
	
	// 这传递的是指针
	func(array, 3);
	
	int a[10];
	int *pa =a // s数组的名求值可获取数组元素的受地址。所以 *pa就是一个指针。
	
	return 0;
}
```

**`java`**

```java
public void test(){
    // 这是个3行的但是列未定义。
	int[][] array= new int[3][];
	array[0] = new int[5]; // 第0行有5列 ，创建有5个整形变量的数组
	arry[1] = new int[4];
	array[2]= new int[3];
}
```



##### 大炮打蚊子案例：

```c
/**
 * 蚊子分布在一个M×N格的二维平面上，每只蚊子占据一格。向该平面的任意位置发射炮弹，炮弹的杀伤范围如下示意：

 O
OXO
 O
其中，X为炮弹落点中心，O为紧靠中心的四个有杀伤力的格子范围。若蚊子被炮弹命中（位于X格），一击毙命，若仅被杀伤（位于O格），则损失一半的生命力。也就是说，一次命中或者两次杀伤均可消灭蚊子。现在给出蚊子的分布情况以及连续k发炮弹的落点，给出每炮消灭的蚊子数。

输入格式:
第一行为两个不超过20的正整数M和N，中间空一格，表示二维平面有M行、N列。

接下来M行，每行有N个0或者#字符，其中#表示所在格子有蚊子。

接下来一行，包含一个不超过400的正整数k，表示发射炮弹的数量。

最后k行，每行包括一发炮弹的整数坐标x和y（0≤x<M，0≤y<N），之间用一个空格间隔。

输出格式:
对应输入的k发炮弹，输出共有k行，第i行即第i发炮弹消灭的蚊子数。

输入样例:
5 6
00#00#
000###
00#000
000000
00#000
2
1 2
1 4
输出样例:
0
2
 * */
#include <stdio.h>

int board[20][20];
int M,N;
// 函数处理逻辑 当前坐标 和 杀上力
int bang(int x, int y, int kill){
    if((x>=0 && x<M) && (y>=0 && y<N) && board[x][y]>0){
        board[x][y] -=kill;
        if(board[x][y]<=0){
            // 蚊子死了
            return 1;
        }else{
            return 0;
        }
    }else{
        return 0;
    }
    return 1;
}
int main(int argc, const char * argv[]){
   scanf("%d%d",&M,&N);
   getchar();// 去除换行符
   for(int i=0;i<M;i++){
       for(int j=0;j<N;j++){
           // 给数组赋值：令蚊子的生命力为2;因为如果为1时炮弹没有击中，而是在
           // 炮弹范围内所以让其生命力为2更好计算。
           board[i][j] = getchar() == '0' ? 0:2;
       }
       // 再次读取换行符
       getchar();
   }
   int k;
   scanf("%d",&k);
   
   for(int i=0;i<k;i++){
    // 用来定义大炮打的一泡的落点
       int x,y;
       scanf("%d%d",&x,&y);
       int count=0;
       count += bang(x,y,2);
       count += bang(x-1,y,1);
       count += bang(x,y-1,1);
       count += bang(x,y+1,1);
       printf("%d\n",count);
           
   }
   
	return 0;
}
```

#### 字符串

字符串就是一串字符。

##### 字符串的定义：

**c语言**：“abcdefeg” 或 字符数组

```c
#include <stdio.h>

int main(void) { 
	// c 语言运行时内存有四个部分: 栈，堆，常量区，代码块
	char *str ="hello world";
	printf("%s\n",str);
	printf("%p\n",str);
	char *str2 ="hello world";
    printf("%s\n",str2);
	printf("%p\n",str2);
	
	// 这的是s3放到了堆栈里了
	char s3[] = "hello";
	printf("%s\n",s3);
	printf("%p\n",s3);
	
	// s4数组是将常量池中的拿过来
	char s4[] = "hello word";
	printf("%s\n",s4);
	printf("%p\n",s4);
	printf("%d\n",sizeof(s3));
	return 0;
}
// 输出：
hello world
0x402004
hello world
0x402004
hello
0x7fffc8a4589a
hello word
0x7fffc8a4588f
6
可以看到 *str 与*str 两个字符的指针指向的位置相同。
```

**c++**

```c++
#include <iostream>
using namespace std;

int main() {
    string name;
    
	cout  << name <<"\n"; // 什么都没有是空字符串
	
	string name2="llk";
	
	cout  << name2 <<"\n"; 

	return 0;
}
```

**java**

```
public void name(){
	String name ="张三";
	System.out.println(name);
	// java一般都是new出来的而这个却可以直接复值；
	// String name = "zhang" 这个其实就是在常量池中创建了一个对象，然后name引用指向常量池； 等价于 char data[] = {'z','h','a','n',y};
	String namestr= new String(data);
	// String name = new String("zhang");
	// 这个是在堆栈中创建一个新的对象将“zhang”放到静态区
}
String str="hello";//直接赋值的方式，先在栈中创建一个对String类的对象的引用变量str,然后查找栈中有没有存放“hello”，如果没有就将“hello”存放在栈，并令star指向“hello”,如果已经有“hello”直接令str指向“hello”

通过构造方法创建字符串对象是在堆内存
String str=new String("hello");//实例化的方式

1）直接赋值（String str = "hello"）：只开辟一块堆内存空间，并且会自动入池(到常量池中)，不会产生垃圾。

2）构造方法（String str=  new String("hello");）:会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池(到常量池中)，需要通过public  String intern();方法进行手工入池(到常量池中)。new的每次都会创建对象，他只会存在堆中，每次调用一次就会创建一个新的对象。 将“hello”放到静态区

在开发的过程中不会采用构造方法进行字符串的实例化。
```

##### 正则表达式与串的匹配

正则表达式是用于对字符串的匹配。

##### 自动机

- 非确定型有限状态自动机(NFA):
- 确定型有限状态自动机(DFA):

```java
// C++;

#include <iostream>
using namespace std;
#include <regex>
int main() {
    string str ="abcd";
    regex r("[a-z]+"); // 匹配一个或多个字母
    string email = "abc123@123.xm";
    regex r1("[a-z0-9]+@[a-z0-9]+\\.[a-z0-9]+");
    bool x=regex_match(str,r);
    cout << x <<endl;

    cout << regex_match(email,r1) << endl;
	return 0;
}
// java 使用类 pattern类
pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数

public static void main(String args[]){
      String content = "I am noob " +
        "from runoob.com.";
 
      String pattern = ".*runoob.*";
 
      boolean isMatch = Pattern.matches(pattern, content);
      System.out.println("字符串中是否包含了 'runoob' 子字符串? " + isMatch);
 }
 
// python
import re;
re(r"正则表达式","匹配的字符")
```

### 线性结构

#### 什么是线性结构：

**线性结构的定义**：

**若结构是非空有限集，则有且仅有一个开始结点和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继**  可表示为如下图所示。

**线性结构中数据元素之间的关系就是这种“直接前驱”或“直接后继”的相邻关系，可以用一个有序对表示,如：a2与a3的关系：<a2,a3>**

[![Di52Is.png](https://s3.ax1x.com/2020/11/15/Di52Is.png)](https://imgchr.com/i/Di52Is)

**线性结构的特点：**

**①** **只有一个首结点和尾结点；**

**② 除首尾结点外，其他结点只有一个直接前驱和一个直接后继。**

**线性结构包括线性表、堆栈、队列、字符串、数组等等，其中，最典型、最常用的是线性表**

#### 线性表：

是一种最简单的线性结构。简单地说，**是一个有序集合：用数据元素的有限序列表示**

是由n个数据元素(结点) 常常将非空的线性表记为L = (a1,a2,a3,a4,a5... an); 

其中

-  L：是线性表的表名
- n表示数据元素的个数，当n=0时成为空表。表中的数据元素a时一个抽象的符号，成为i在ai在线性表中的位序。

[![DizsV1.png](https://s3.ax1x.com/2020/11/15/DizsV1.png)](https://imgchr.com/i/DizsV1)



##### **线性表四个基本特征：**

**1.集合中必存在唯一的一个“第一元素”；**

**2.集合中必存在唯一的一个“最后元素”；**

**3.除最后元素之外，其它数据元素均有唯一的“直接后继”；**

**4.除第一元素之外，其它数据元素均有唯一的“直接前驱”；**

**线性表的顺序表示又称为**：**顺序存储结构或顺序映像**

##### 线性表的存储

用一组地址连续的存储单元依次存放线性表中的数据元素。**借助元素在存储器中的**相对位置来表示  **数据元素间的逻辑关系**

#### 顺序表

##### 定义：

**顺序表**是线性表的顺序存储表示的简称，它指的是，“用一组**地址连续**的存储单元**依次存放**线性表中的数据元素”，即以“**存储位置相邻**”表示“位序相继的两个数据元素之间的前驱和后继的关系

>(有序对<ai-1，ai)”，并以表中第一个元素的存储位置作为线性表的起始地址，称作**线性表的基地址**

**顺序存储定义：** 把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构

**顺序存储方法：**用一组地址连续的存储单元依次存储线性表的元素，可通过数组V[n]来实现

**顺序表的类型定义：**

```c
#define  MAXSIZE 100     //最大长度
typedef  struct {
  ElemType  *elem;     //指向数据元素的基地址
  int  length;          //线性表的当前长度                                                      
 }SqList；
```

**顺序表存储结构定义：**

```c
#define MAXSIZE 10000	//图书表可能达到的最大长度 
typedef struct			//图书信息定义
{ 
   char no[20];			//图书ISBN
   char name[50];		//图书名字
   float price; 			//图书价格
}Book; 
typedef struct
{ 
   Book *elem;	//存储空间的基地址 
   int length;		//图书表中当前图书个数 
}SqList;		//图书表的顺序存储结构类型为SqList

```

##### **顺序表的特点：**

**（1）利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与存储结构一致**

**（ 2 ）在访问线性表时，可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为， 访问每个元素所花时间相等**　

##### **顺序表的优缺点:**

**优 点：**

1. **存储密度大 （结点本身所占存储量 / 结点结构所占存储量）**
2. **可以 随机存取 表中任一元素**

**缺点：**

1. **在插入、删除某一元素时，需要移动大量元素**
2. **浪费存储空间**
3. **属于静态存储形式，数据元素的个数不能自由扩充**

**c语言动态分配函数：**

**malloc(m)：开辟m字节长度的地址空间，并返回这段空间的首地址**

**sizeof(x)：计算变量x的长度**

**free(p)：释放指针p所指变量的存储空间，即彻底删除一个变量**

##### 实现线性表

###### C语言

[![DiHTUg.png](https://s3.ax1x.com/2020/11/15/DiHTUg.png)](https://imgchr.com/i/DiHTUg)

代码：

```c
#include <stdio.h>

#define MAX 10

// 使用结构体
struct Slist{
    int data[MAX];
    int length;
};
// 初始化
void init(struct Slist* p){
    p->length =0;
}
// 打印
void printList(const struct Slist* p){
    for(int i=0;i<p->length;i++){
        printf("%d",p->data[i]);
    }
    putchar('\n');
    
}
// 插入
int insert(struct Slist* p, int k, int x){
    // 判断插入的位置
    if(k<0 || k> p->length || p->length==MAX-1) return 0; // 表示失败
    for(int i=p->length-1;i>=k;i++){
        // 元素向后挪一位
        p->data[i+1] = p->data[i];
    }
    p->data[k] = x;
    p->length++;
    return 1;
    
}

// 删除
int delete1(struct Slist* p, int k, int *px){
    if(k<0 || k >= p->length) return 0;
    else {
        *px = p->data[k];
        for(int i= k+1; i<p->length;i++){
            p->data[i-1] = p->data[i];
        }
        p->length--;
        return 1;
    }
}
int main(void) { 
    struct Slist a;
    init(&a);
    // 插入 在0号元素插入x
    int k=0,x=11;
    insert(&a,k, x);
    
    // 删除并将返回删除的值的地址。
    int addr;
    delete1(&a, 1,&addr);
    // 这里传入a的话就会copy一份数组了，所以这里使用地址进行传入
    printList(&a);
	return 0;
}
```

###### c++

```c++
#include <iostream>
#include <list>
#include <vector>
#include <stack>
using namespace std;
int main(int argc ,const char * argv[]) {
   vector<int> v;
   v.push_back(11);
   v.push_back(12);
   v.push_back(13);
   // 使用迭代器
   vector<int> ::iterator it;
   for(it=v.begin(); it!=v.end();it++){
       cout<< *it << ",";
   }
   cout << endl;
    // 插入
   v.insert(v.begin(),666); // 在 0 号位置进插入
   v.insert(v.begin()+2, 333); // 在 2号位置进行插入
    // 删除
   v.erase(v.begin()+1); // 
   for(int i:v){
       cout << i << ",";
   }
    
   cout << endl;
	return 0;
}
```

###### **java**

```java
public void testArrayList(){
    ArrayList<Integer> list = new ArrayList<>();
   	list.add(123);
    list.add(234);
    // 在1号位置插入
    list.add(1,666);
    // 移除某个下标的。返回删除的元素
    int k=list.remove(2);
    
}
```

###### **Python**

```python
a=list();
a.append(11);
a.append(222);
# 插入
a.insert(3,33);
# 删除 用栈的方式弹出
a.pop(1);
```

#### 链表

#### 栈

#### 队列



### 树

### 优先队列与集合

