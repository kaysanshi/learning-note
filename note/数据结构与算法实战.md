## 数据结构与算法实战

### 程序的本质

程序是有一系列的机器指令构成。

程序=数据结构+算法

数据结构与算法是相辅相成的。

#### **数据结构：**

数据结构是计算机存储，组织数据的方式。数据结构是指的相互之间存在一种或多种特定关系的数据元素的集合。通常情况下精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。

简言之：是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。

<font color="red">“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。</font>

**数据的逻辑结构：**

数据的逻辑结构反应的是数据元素之间的逻辑关系，是指数据元素之间的前后间的关系，而与元素所存储的位置无关。逻辑结构包含：

- 集合：数据结构中的元素之间除了“同一集合”的相互关系外，别无其他关系。
- 线性结构：数据结构中的元素存在一对一的相互关系。
- 树形结构：数据结构中的元素存在一对多党的相互关系。
- 图形结构：数据结构中的元素存在多对多的相互关系。

一般按照逻辑结构分类数据结构可分为：

线性结构：线性结构就是表中各个结点具有线性关系。如果从数据结构的语言来描述，线性结构应该包括如下几点：

- 线性结构是非空集合

- 线性结构有且仅有一个开始结点和一个终端结点。

- 线性结构所有的结点都最多有一个直接前趋结点和一个后继结点。

  包含：线性表，栈，队列，串

非线性结构：线性结构就是表中各个结点具有线性关系。如果从数据结构的语言来描述，线性结构应该包括如下几点：

- 非线性结构是非空集。

- 非线性结构的一个结点可能有多个直接结点和多个后继结点。

  包含：数组，广义表，树结构和图结构

**数据的物理结构：**

指数据的[逻辑结构]在计算机存储空间的存放形式。

数据的物理结构是数据结构在计算机中的表示（又称映像），它包括数据元素的机内表示和关系的机内表示。由于具体实现的方法有顺序、链接、索引、散列等多种，所以，一种数据结构可表示成一种或多种存储结构。

数据元素的机内表示（映像方法）： 用二进制位（bit）的位串表示数据元素。通常称这种位串为节点（node）。当数据元素有若干个数据项组成时，位串中与各个数据项对应的子位串称为数据域（data field）。因此，节点是数据元素的机内表示（或机内映像）。

关系的机内表示（映像方法）：数据元素之间的关系的机内表示可以分为顺序映像和非顺序映像，常用两种存储结构：顺序存储结构和链式存储结构。顺序映像借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。非顺序映像借助指示元素存储位置的指针（pointer）来表示数据元素之间的逻辑关系。

**数据的存储结构：**

数据的逻辑结构在计算机存储空间中的存放形式称为数据的物理结构(也称为存储结构)。一般来说，一种数据结构的逻辑结构根据需要可以表示成多种存储结构，常用的存储结构有顺序存储、链式存储、索引存储和哈希存储等

数据的顺序存储结构的特点是：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系；非顺序存储的特点是：借助指示元素存储地址的指针表示数据元素之间的逻辑关系

#### 算法：

算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰[指令]，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的[输入]，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用[空间复杂度]与[时间复杂度]来衡量。

算法中的指令描述的是一个[计算]，当其[运行]时能从一个初始状态和（可能为空的）初始输入开始，经过一系列**有限**而清晰定义的状态，最终产生**输出**并**停止**于一个终态。一个状态到另一个状态的转移不一定是确定的。随机化算法在内的一些算法，包含了一些随机输入。

**特征：**

- 有穷性（Finiteness：算法的有穷性是指算法必须能在执行有限个步骤之后终止；
- 确切性(Definiteness)：算法的每一步骤必须有确切的定义；
- 输入项(Input)：一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；
- 输出项(Output)：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；
- 可行性(Effectiveness)：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算[步骤](https://baike.baidu.com/item/步骤/7066340)都可以在有限时间内完成（也称之为有效性）

**算法的评定：**

- 时间复杂度：算法的时间复杂度是指执行算法所需要的计算工作量。一般来说，计算机算法是问题规模n 的函数f(n)，算法的时间复杂度也因此记做。T(n)=Ο(f(n))
- 因此，问题的规模n 越大，算法执行的时间的增长率与f(n) 的增长率正相关，称作[渐进时间复杂度](https://baike.baidu.com/item/渐进时间复杂度)（Asymptotic Time Complexity）。
- 空间复杂度：算法的[空间复杂度](https://baike.baidu.com/item/空间复杂度/9664257)是指算法需要消耗的内存空间。其计算和表示方法与时间[复杂度](https://baike.baidu.com/item/复杂度)类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。
- 正确性：算法的正确性是评价一个算法优劣的最重要的标准。
- 可读性：算法的可读性是指一个算法可供人们阅读的容易程度。 [1] 
- 健壮性：健壮性是指一个算法对不合理数据输入的反应能力和处理能力，也称为**容错性**

### 函数与递归

为何自己写不出递归呢？

需要 需要确定信念。确定递归的结束条件和递归条件

```java
 /**
     * 递归函数求阶乘
     *
     * @param n
     * @return
     */
    private static int fact(int n) {
        // 递归必须确定结束条件
        if (n < 2) {
            return 1;
        }
        return n * fact(n - 1);
    }

    /**
     * 汉诺塔
     *
     * @param n   盘子数
     * @param src 元盘子
     * @param mid 中间盘子
     * @param tar 目标盘子
     */
    private static void hanoi(int n, int src, int mid, int tar) {
        // 确定结束条件
        if (n == 1) {
            System.out.println(src + "-->" + tar);
        } else {
            hanoi(n - 1, src, tar, mid); // 把n-1个盘子从元盘子借助目标柱子放到中间柱子
            hanoi(1, src, mid, tar); // 把一个盘子从原主借助中间住放到目标住
            hanoi(n - 1, mid, src, tar); // 把n-1个盘子从中间住借助源住放到目标住
        }

    }
```

### 数组与字符串

#### 数组：

就是线性表的实现。

c语言

```c
#include <stdio.h>
#include <stdio.h>
// 这个地方其实是传入的数组的地址 *array，和大小
int func(int *array,int size){
    // array[0] 其实就是指针 array求值得出首地址
	return array[0]; // 等价于 *(array+0);
}
int main(int argc,const char * argv[]){
    // array是一个数组
	int array[100] = {11,22,33,44};
    // 指针的形式
	int *p = malloc(100 * sizeof(int));
    // 在这里是获取到了数组的指针
    printf("%d\n",*(array+1));
    
    // 传入的其实是数组首地址的指针
	printf("%d\n",func(array,100));
	return 0;
}
```

java

```java
public class main{
	public static void main(String[] args){
		int [] array = new int[10];
		array[1]=222;
		array[2]=333;
		System.out.println(array.length);
        ArrayList<Integer> list = new ArrayList<>();
        list.add(123);
        list.add(22);
        System.out.println(list);
	}
}
```

##### 查找



```c
/**
** 根据值找到下标
*/
int findX(int * array,int size,int x){
	int flag=0;
	int index=-1;
	for(int i=0;i<size;i++){
		if(array[i]==x){
			flag =1;
			index = i;
		}
	}
	return index;
}
/**
** 根据下标找到值,并把原来的地址给返回过来
*/
int findElement(int * array,int size, int k, int *px){
    if(k>=size || k<0) return 0;
    else{
        *px=array[k];
        return 1;
    }
}
/**
* 查找最大的。
*/
int findMax(int * array, int size){
    // 是将数组中的一个元素初始为max;
    int max =array[0];
    for(int i=1;i<size;i++){
        if(max<array[i]) max = array[i];
    }
    return max;
}
int main(int argc,const char * argv[]){
	int array[10] = {111,112,33,44,55};
	int x;
	x=12;
	int k;
	k= findx(array,10,x);
	printf("%d/n",k);
    int m,flag;
    // 传入的是数组引用，长度，和下标，和地址
    flag= findElement(array,10,3,&m);
    printf("%d,%d/n",flag,m);
	// 查找最大值
    int max ;
    max = findMax(array,10);
    printf("%d\n",max);
	return 0;
}
```

##### **求两个100位的十进制的和。**

```c
int main(int argc, const char * argv[]){
    // 
    // 思路 用数组 ，数组的底位存0号元素(如果0号元素存在高位，则是不可以进位的)
    int a[11] = {0,9,8,7,6,5,4,3,2,1};
    int b[11] = {1,2,3,4,5,6,7,8,9};
    int sum[11] = {0};
    int carry=0;//进位操作
    // i< 11是为了计算最后一个
    for(int i=0;i<11;i++){
        int s;
        s=a[i]+b[i]+carry;
        carry = s/10;
        sum[i] = s%10;
    }
    for(int i=10;i>=0;i--){
        printf("%d",sum[i]);
    putchar('\n');
    }
	return 0;
}
```

java中操作：

```java
public static void main(String[] args){
	BigInteger a= new BigInteger("12345678");
	BigInteger b= new BigInteger("12345678");
	BigInteger c= a.add(b);
	System.out.println(c);
}
```

#### 二维数组

二维数组的实质：数组的数组。数组中的每一个元素仍然是个数组。

逻辑上可看做二维，其实并不是二维的

**c语言**

`int array [][]  与 int **`



### 线性结构

### 树

### 优先对列与集合

