## MySQL查询优化

### 重要的概念：

域：是一组具有相同数据类型的值得集合，例如：实数，整数，介于某个范围的数

关系：关系代数的对象是关系，单一的数据结构,D1XD2X...Dn的子集叫做在域D1,D2,Dn上的关系，可以表示为 R(D1,D2,...Dn)  R是关系名，n:关系的目或度

关系的表示：关系是一个二维表，表的每行是对应的一个元组，表中的每一列对应的是一个域，

**关系的性质：**

- 列是同质的（homogeneous）
- 不同的列可出自同一个域
- 列的顺序无所谓，可以任意交换
- 任意两个元组的候选码不能相同
- 行的顺序无所谓，行的次序可以任意交换
- 分量必须取原子值

属性：关系中不同列可以对应相同的域，为了加以区分，必须给每列起一个名字，称为属性(attribute)n目关系必须有n个属性

码：

- 候选码：关系中的某一属性组的值能唯一的标识一额元组，简单的情况：候选码只包含一个属性
- 全码：关系模式中的所有的属性组是这个关系模式的候选码，
- 主码：如一个关系中有多个候选码则选定其中一个为主码，
- 主属性：候选码的属性称为主属性，
- 非主属性：不包含在任何候选码中的属性称为非主属性，

外码：设F是基本关系R的一个属性或一组属性，但不是关系R的码。如果F与基本关系S的主码Ks对应则F是R的外码 R是参照关系，S是被参照关系或者是目标关系

- 关系R和S不一定是不同的关系
- 目标关系S的主码Ks和参照关系的外码F必须定义在一个域上
- 外码不一定要与相应的主码同名

投影：可以选择性的显示关系的某些属性

笛卡尔积：给定一组域，允许某些域是相同的,

- 所有域的所有取值是一个组合，
- 不能重复

```
D1,D2,...Dn的笛卡尔积为： D1*D2*..Dn={(d1,d2,....dn)| di属于Di,i=1,2,...n}
```

元组：笛卡尔积中的每一个元素（d1,d2,d3...dn) 叫做一个元组，（A,B,C） 括号包括起来

分量：笛卡尔积中每一个元素的值如：d1:是一个值。 d2也是，则这些叫做分量，即：括号内每一个元素，

基数：若Di(i=1,2,3,..n)为有限集，其基数为Mi(i=1,2,...n)

笛卡尔积表示方法：可以表示为一张二维表，表中的行对应一个元组，表中的每一列对应一个域

```
例如：A={A1,A2} B={B1,B2} C={C1,C2,C3}

A1XB2XC3={（A1,B1,C1）,(A1,B1,C2),(A1,B1,C3),(A1,B2,C1),(A1,B2,C2),(A1,B2,C3),(A2,B1,C1),(A2,B1,C2),(A2,B1,C3),(A2,B2,C1),(A2,B2,C2),(A2,B2,C3)}看似和排列组合一样

则基数为2X2X3=12
同样可以转换为一张二维表

```

选择：

并集，差集：

```
Select A.*,B.*  // "投影"
From A,B // 笛卡尔积
Where A.c1=1 and A.c2=B.c2 or B.c1>100  // "选择"
UNION // 并集，差集
Select A.*,B.*
From A,B
Where A.c1=1 and A.c2=B.c2 or B.c1>100 

```

#### 常见的关系操作

查询的操作：选择，投影，连接，除，并，差，交，笛卡尔积，（选择，投影，并，差，笛卡尔积）基本操作

数据更新：插入，删除，修改

关系操作的特点：

集合操作方式：操作对象和结果都是集合，一次一集合的方式

#### 完整性检查：

##### 实体完整性：

- 实体完整性是针对基本关系而言，一个基本表通常对应现实世界的一个实体集，
- 实体可以区分具有唯一标识
- 关系模型以主码为唯一标识
- 主码中的属性不可以为空值

##### 参照完整性

若属性(或属性组)F是基本关系R额外码他与基本关系S的主码Ks相对应(基本关系R和S不一定是不同的关系)则对应R中的每个元组在F上必须为：空值(F上的属性均为空值)，或者等于S中的某个元组的主码值

##### 用户定义完整性

- 针对某一具体关系数据库的约束条件，反应某一具体应用所涉及的数据必须满足的语义要求
- 关系模型提供定义检验这类的完整性的机制，以便于用户统一系统的方法处理他们，而不需由应用程序承担，

### 数据库调优

数据库调优可以使得数据库应用运行的更快，目标是：使得数据库有更高的吞吐量，更短的相应时间。被调优的对象是整个数据库管理系统总体。查询语句调优：调优的对象是一条语句。

调优有以下方式：

#### 人工调优

主要依赖于人，效率低下，要求操作者完全理解常识所依赖的原理，还需对应用，数据库管理系统，操作系统，以及硬件有广泛的理解，最体现维护人员的价值。

#### 基于案例的调优

总结经典应用案例的情况中数据库参数的推荐配置值，数据逻辑层设计等，现况，从而为用户的调优工作提供一些案例和参考借鉴，但这种方式忽略了系统的动态性和不同系统的存在的差异系。

##### 自调优

为数据库系统建立一个模型，根据“影响数据库系统性能效率的因素”，数据库系统自动进行参数的配置。一些商业数据库，实现了部分自调优技术

### 数据库调优五个阶段的主要技术

1.应用情况的估算：

应用的使用情况（把业务逻辑转换为数据库的读写分布逻辑，以是读多写少还是读写均衡来换分OLTP和OLAP，应用数据库的并发情况，并发是否可以池化），数据量，对数据库的压力，峰值压力等做一个预估。

2.系统选型策略：

确定什么样的数据库可以适用应用场景，并确定数据库是使用的开源数据库还是商业数据库，是使用集群还是单机系统，同时对操作系统，中间件，硬件，网络等选型。

3.数据模型设计：主要根据业务逻辑，从几个角度考虑表的逻辑结构：

- E-R模型设计：遵循E-R模型设计原理，偶尔的适当程度的非规范化可以改善系统查询性能。
- 数据逻辑分布策略:目的减少数据请求的不必要的数据量，把用户需要的数据返回，可用的技术如分区，用E-R模型分表等(如互联网企业典型的用法，根据业务的不同，进行分库，分表操作)
- 数据物理存储策略:目的减少IO，如启用压缩技术，把索引和表数据的存储分开，不同的表的数据分布不同的表空间，不同表空间分布在不同的物理存储上（尤其是读写量大的表空间分布在不同的物理存储上），日志，索引和数据分布在不同的物理存储上
- 索引：在查询频繁的对象上建立索引，使用索引的正效应大于负效应（索引的维护存在消耗）

4.SQL设计

编写正确的，查询效率高的SQL语句，这依据的主要是“查询重写规则”,编写语句的过程要注意保障SQL能利用到索引

5.数据库功能的启用:数据库为提高性能的一些功能，可合理使用，具体如下：

- 查询重用：根据实际情况，进行配置，可缓存查询执行计划，查询结果等，
- 数据库参数的设置：可设置合适的参数如数据缓冲区等，模型系统预运行，在备用系统上模拟实际运行环境，加大压力进行系统测试，提前发现问题。

6.系统监控与分析，在工业环境中加强对系统的运行监控和日志的分析工作

- 应用系统表现：收集用户的信息，系统存在的问题，这都是用户第一时间发现的。
- OS环境监控：实现监控CPU,内存，IO等，并对比实时情况与历史正常情况。
- 数据库内部状况监控：一些数据库提供系统表，视图，工具等手段，向用户提供数据库运行过程中的内部信息，如锁的情况，这些都是需要实时的监控，并对比实时情况与历史正常情况。
- 日志分析：在数据库的日志，操作系统的日志中找出异常事件，定位问题。



### 数据库查询优化概述

数据库查询优化技术主要包括查询重用技术，查询重写技术，查询算法优化技术，并行查询优化技术，分布式查询优化技术，这6项构成“广义数据库查询优化”

查询重写技术，查询算法优化技术可称为“狭义数据库查询优化”

可分为代数优化(逻辑优化)或非代数优化(物理优化)

逻辑优化：主要依据关系代数的等价变化做一些逻辑变换  如：“查询重写规则”

物理优化：主要根据数据读取，表连接，表连接顺序，等技术。如：“查询算法优化”

#### 查询优化技术

##### 查询重用技术：

查询重用技术是尽可能利用先前的执行结果，已到达节约查询计算全过程的时间并减少资源消耗的目的，目前的查询重用技术集中在两个方面：

- 1.查询结果重用：在缓冲区中存放该SQL语句文本和最后的结果集，当同样的SQL输入时，直接把结果返回。查询结果的重用技术，节约计划生成时间，减少了查询执行全过程的资源消耗。
- 2.查询计划的重用：缓存一条查询语句的执行计划及其相应的语法树结构，查询计划的重用技术减少了查询计划生成的时间和资源消耗。

查询重用技术利弊：

弊端：结果集很大会消耗内存资源很多，同样的SQL不同的用户应该获取的结果集可能不同。

利端：节约CPU和IO消耗，在实际使用过程中，趋利避害，根据实际情况选用。

##### 查询重写：

查询重写是查询语句的一种等价转换，即对任何相关模式的任意状态都会参生相同的结果。

1.将查询转换为等价的效率更高的形式，例如将效率低的谓词转换为效率高的谓词，消除重复条件

2.尽量将重写为等价，简单且不受表顺序限制的形式，为物理查询优化阶段提供更多的选择，如视图的重写，子查询的合并转换等。

重写依据：

1.关系代数的等价变换规则对查询重写提供了理论支撑。

2.查询重写后，查询优化器可能生成多个连接路径，可以从候选者中择优

查询重写是基于语法级，代数级，语义级的优化，可以统一归属到逻辑优化的范畴：基于代价估算模型是物理层面的优化，是从连接途径中选择代价最小的路径的过程。

重写思路：

1.将过程性查询转换为描述性的重写，如视图重写

2.将复查的查询(如嵌套，外连接消除，嵌套连接消除)尽可能转换为多表连接查询。

3.将效率低的谓词转换为效率高的谓词（如等价谓词重写）

4.利用等式和不等式的形式，简化Where,Having条件

5.如何改进现有查询重写规则的效率，如何发现更多更有效的重写规则，是查询优化的研究内容之一

重写的核心一定是“等价转换”只有等价才能转换。

#### 查询优化技术类型

1.语法级：查询语言层的优化，基于语法进行优化，

2.代数级：查询使用形式逻辑进行优化，运用关系代数的原型优化

3.语义级：根据完整性约束，对查询语句进行语义分析，推知一些可优化的操作。

4.物理级：物理优化技术，基于代价估算模型，比较得出各种执行方式代价最小的。

#### 查询优化算法 ：

查询优化求解给定查询语句的高效执行计划过程。包括子问题的求解，不同子问题的求解过程。

查询计划称为查询树，他由一系列内部的操作符组成，这些操作符被按一定的运算关系构成一个查询的执行方案。简单的说是，就是A和B先连接，得到中间结果，然后在和另外的表C连接到新的中间放式，直至所有表都被连接完毕。

#### 生成最优查询计划的策略：

1.基于规则优化：

根据经验或一些，已经探知或被证明的有效的方式，定义为“规则”，用这些规则简化查询计划生成过过程中符合可被化简操作，使用启发式规则排除一些明显不好的存取路劲，这就是基于规则的优化。

2.基于代价优化：
根据一个代价评估模型，在生成查询计划的过程中，计算每条存取路径的花费，然后选择代价最小的最为子路径，这样直至所有表连接完毕得到一个完整的路径。总代价=CPU代价+IO代价

Mysql和PostgreSQL就是采取的基于规则和代价估算的查询优化策略

**Mysql显示SQL语句的查询执行计划：**

EXPLAIN[explain_type] explainable_stmt

可选项包括：exteded|partitions|format=format_name

format_name:TRADITIONAL|JSON

说明：
1.ExPLAIN命令，显示SQL语句查询执行计划

2.EXPLAINEXTENDED,显示SQL语句的详细的查询执行计划；之后可以用“SHOW WARNINGS"命令查看详细的信息。

3.EXPLAIN PARTITION命令显示SQL语句的带有分区表细腻度的查询执行计划。

4.EXPLAIN命令输出格式有两种：json和传统类型，按行隔离。

5.explainable_stmt,可以被EXPLAIN执行的SQL语句，包括：Select,insert,update,delete

#### 查询优化并行的条件：

1.系统中的可用资源，如内存，高速缓存中的数据量

2.cpu的数目，

3.运算中的特定代数运算符。

在同一个SQL内查询并行可以分为：

1.操作内并行。将同一操作如单表扫描操作，两表连接操作，排序操作，分解为独立的自操作，由不同的CPU同时执行。

2.操作间并行。一条SQL查询语句可以分解为多个子操作，由多个CPU执行。

在分布式数据库系统中，查询策略优化是查询优化的重点。主要是数据传输策略，A,B两两节点的数据进行连接，是A节点数据传输到B节点或是B到A节点和局部处理优化（传统的单节点数据库的查询优化技术）分布式的数据库系统中的代价估算模型为 总代价=IO代价+CPU代价+通信代价

### 查询的基本操作：

##### 选择操作：

对应的是限制条件(格式类似“field<op> consant",field表示列对象，op是操作符，”=”，“>")操作对象是二维表中的行。

优化方式：选择操作下推

目的：尽量减少连接操作前的元数组，使得中间临时关系尽量少（元组数少得到连接的元组数就少）

好处：减少IO和CPU消耗，节约内存空间。

##### 投影操作：

对应的是Select查询的目的列对象，

优化方式：投影操作下推

目的：尽量减少连接操作前的列数，使得中间临时关系尽量小（投影操作是使得一条元组“尽量小”）

好处：这样不能减少IO（多数数据库都是行存储，元组是读取的最基本单位，所以想要操作列则必须读取一行数据）,但是可以减少连接后的元组的大小，节约内存空间。

##### 连接操作：

对应的是连接条件（格式类似于“field_1<op>field_2”,field_1和field_2是表示不同表上的列对象，op是操作符，表示两个表连接的条件。

多表连接中每个表被连接的顺序决定这效率。对个表之间那种连接方式最高效，是ABC,还是ACB,还是BAC

多表连接每个表被连接的顺序被用户语义定义，查询语句多表连接有不同的语义（笛卡尔积，内联，外联）这些决定这表之间的前后连接次序是不能随意更换的，否者结果集中的数据是不同的，因此，表的前后连接次序是不能随意变换的。

### 逻辑查询优化包括的技术

##### 子查询：

当一个查询是另一个查询的子部分时，称为子查询。（查询语句中嵌套有查询语句）

##### 子查询的子部分包括的情况：

1.目标列位置：子查询如果位于目标列，则只能标量子查询，否者数据库可能出现“错误：子查询必须只能返回一个字段”的提示。

子查询返回的是一个列记录，可以称为标量 select t1,c1,(select t2.c2,from t2 where k2=1) from t1,t2

2.from子句的位置：

select*from t1,(select * from t2 where t1.k1=t2.k2)  error:every derived table must have its own alias

select*from t1,(select * from t2 where t1.k1=t2.k2) As A_at2 error: unKonow column 't1.k1' in 'where clause'

3.where子句的位置

出现在where子句的子查询是一个条件表达式的一部分，而表达式可以分解为操作符和操作数，根据参与运算的不同的数据类型，操作符也不尽相同如int型：“<,>,=,<>”等，对这子查询均有一定的要求(如int型的等值操作，要求子查询必须是标量子查询)。另外子查询出现在where子句中的格式，也有用谓词指定的一些操作如In,between,exists,等。any 可以与=、>、>=、<、<=、<>结合起来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的任何一个数据

select * from t1 where k1 in(select k2 from t2)

select * from t1 where k1 >=ANY(select k2 from t2)  any关键词可以理解为“对于子查询返回的列中的任一数值，如果比较结果为true，则返回true”。

select * from t1 where k1 <=SOME(select k2 from t2)

select * from t1 where NOT EXISTS (select k2 from t2 where k2=100)

4.Join/oN子句位置：

Join/oN子句可以拆分为两部分，一是Join块类似于from子句，二是on块类似于where子句，这两部分都可以出现子查询。子查询的处理方式同from子句和where子句。

5.groupby子句位置：

目标列必须和groupBy关联，可以将子查询写在groupby位置处，但子查询用groupby处没有实用意义。

6.orderBy子句位置：

可以将子查询写在orderby位置处，但orderby操作是作用在整条SQL语句中，所以没有实际意义。

##### 子查询的类型---从对象关系间看

1.相关子查询：子查询的执行依赖外层父查询的一些属性值。子查询因依赖于父查询的参数，当父查询的参数改变时，子查询需要根据新参数值重新执行(查询优化器对相关子查询进行优化的意义)

2.非相关子查询：子查询的执行，不依赖于外层父查询的任何水属性值。这样子查询具有独立性，可独立求解，形成一个子查询计划优先于外层的查询计划。

##### 子查询的类型---从特定谓词看：

1.[not] in/all/any/some子查询。语义相近表示“存在/所有/任何/任何、”左面是操作数，右面是子查询，是最常见的子查询类型之一。

2.[not]exists子查询：半连接语义，表示“存在”，没有左操作数，右面是子查询，也是最常见的子查询类型之一

3.其他子查询

##### 子查询类型---从语句的构成复杂度看：

1.spj子查询：由选择投影，连接，组成的子查询。

2.groupby子查询：spj子查询加上分组，聚集操作组成的查询。

3.其他查询：GroupBy加上其他子查询如 top-N,limit/offset,集合，排序。

##### 子查询类型---从结果的角度看：

1.标量子查询：子查询返回的结果集类型是一个简单的值

2.单行单列子查询：子查询返回的结果集类型是零或一条单元组。相似与标量子查询，但可能返回零元组

3.多行单列子查询：子查询返回的结果集类型是多条元组，但只有简单列。

4.表子查询：子查询返回的结果类型是一个表。

#### 子查询优化：

在数据库实现早期，查询优化器对子查询一般采用嵌套执行方式，对父查询的每一行，都执行一次子查询，这样子查询会执行很多次。效率低。子查询优化后好处如下：子查询不用执行多次。优化器可以根据统计信息来选择不同的连接方法和不同的连接顺序。比如子查询的连接条件，过滤条件分别变成了父查询的连接条件，这种条件下推方式可以提高执行效率



##### 如何子查询优化：

###### 1.子查询合并： 

在某些条件下（语义等价：两个查询块产生同样的结果集）多个子查询能够合并成一个子查询（合并后还是子查询，以后通过其他技术消除掉子查询）这样可以把多次连接减少为单次表扫描和单次连接。mysql未提供支持

select * from t1 where a1<10 and (exists (select a2 from t2 where t2.a2<5 and t2.b2=1) OR exists (select a2 from t2 where t2.a2<5 and t2.b2=2))

可以优化为：

select *from t1 where a1<10 and (exists(select a2 from t2 where t2.a2<5 and (t2.b2=1OR t2.b2=2)) // 两个exists子句合并为一个，条件也进行了合并。

###### 2.子查询展开：

子查询反嵌套，又称子查询上拉。

把一些子查询置于外层的父查询，作为连接关系与外层父查询并列，其实是把某些子查询重写为等价的多表连接操作（展开后子查询不存在了，外部查询变为多表连接了。）带来的好处是，有关的访问路径，连接方法和连接顺序可能被有效使用，使得语句的层次尽可能减少。常见的in/any/some/all/exists依据情况转换为半连接，普通类查询等情况属于此类。

select * from t1,(select * from t2 where t2.a2>10) v_t2 wheret1.a1<10 and v_t2.a2<20：
可优化为：
select * from t1,t2 where t1.a1<10 and t2.a2<20 and t2.a2>10

###### 3.聚集子查询消除

通常一些系统支持的是标量聚集子查询消除

如： select * from where t1.a1>(select avg(t2.a2) from t2)

##### MySql可以优化哪些格式的子查询：

###### 支持对简单的select查询中的子查询优化：

简单的select查询中的子查询

带有Distinct,ORDERBY,LIMIT操作的简单SELECT查询中的子查询、

例如：create table t1(a1 int,b1 int,primary key (a1));create table t2(a2 int,b2 int,primary key (a2));create table t3(a3 int,b3 int,primary key (a3));c插入1万条数据

查询执行计划如下：explain extended select * from t1 where t1.a1<100 and a1 in (select a2 from t2 where t2.a2>10);

###### Mysql子查询进行优化支持哪些：

带有UNION操作。带有groupby,having,聚集函数。使用orderby中带有limit，内表，外表的个数超过MySql支持的最大的连接数（63张表）。

1.子查询合并技术不支持：例1：

explain extended select * from t1 where a1<4 and (exists (select a2 from t2 where t2.a2<5 and t2.b2=1) or exists(select a22 from t2 where t2.a2<5 and t2.b2=2));

t2表中执行了2次子查询，如果支持子查询合并技术则天表置执行一次子查询。

人为合并查询 条件为 “t2.b2=1 or t2.b2=2” t2表上的子查询，子查询执行一次。

explain extended select * from t1 where a1<10 and exists (select a2 from t2 where t2.a2<5 And (t2.b2=1or t2.b2=2))

2.子查询展开（子查询反嵌套）技术 支持的不够好：例2

explain extended select * from t1 ,(select * from t2 where t2.a2>10) v_t2 where t1.a1<10 and v_t2.a2<20;

查询计划上在t2上的子查询被单独执行，没和t1进行嵌套循环连接，子查询没有被消除，所以mysql支持子查询反嵌套技术有限。

3.聚集查询消除 不支持

#### 视图重写：

#### 等价谓词重写：

#### 条件化简：

#### 外连接消除：

#### 嵌套连接的消除：

#### 连接消除：

#### 语义优化：

#### 非SPJ的优化：



